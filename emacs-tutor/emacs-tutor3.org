#+TITLE: Emacs Mini Manual (PART 3) - CUSTOMIZING AND EXTENDING EMACS
* Why customize and extend Emacs?
:PROPERTIES:
:ID:       bbed4318-de81-421d-a6c4-04b40b60b591
:END:
Emacs comes with a default settings. Some interesting features are
disabled and hidden, i.e. Ibuffer, Semantic, electric
modes... Probably to make it more user friendly to new users and
behave more like "normal" editors, i.e. Normal users do not expect
automatic pairing of punctuation marks like parentheses, brackets,
curly brackets...

Because the nature of Emacs is an extensible system, people write
extensions to improve Emacs and share with others. The extensions
improve various aspects of Emacs: Improve and add editing features,
integrate 3rd party tools, add programming languages supports, change
Emacs appearance... Without the ability to extend, Emacs will just be
another obscure editor with some useful features but cannot meet the
demands of people, because different people have different needs, and
Emacs maintainers cannot provide them all and integrate all into
Emacs. With the extensibility, people can bend Emacs the way they
want, much like Lisp.

Unlike other editors which encourage users to stay with the default as
much as they can, Emacs encourages users to customize and extend Emacs
as much as they can.

In the old days, when Emacs did not have a package managaer and did
not have many learning resources like now, it's really uneasy to
customize Emacs, because to customize Emacs properly you have to read
a decent chunk of the Emacs Lisp manual. Many of us, including me, do
not have that luxury of time. The way I learned to customize Emacs was
copying little code snipopets that solve specific problems - when I
encountered them - and paste everything in my =~/.emacs= file. I also
had to download Emacs packages manually and load it manually in
=~/.emacs=. I hope that this guide helps you to be at least as good as
me in customzing Emacs without having to spend a long time in
collecting configurations, or reading the whole Emacs Lsip
manual. After you finish this chapter, you can dive in the Emacs Lisp
manually if you want, and easier.

* Just enough Emacs Lisp
:PROPERTIES:
:ID:       bd3c88d9-3a94-483f-bc35-3b5c215d0e79
:END:
In this section, you only need to read and understand. I will list the
commonly used function used for customizing Emacs that we will use in
later sections. It's important that you understand the core
ideas. After you finish the sub-sections of this section, we will play
with Emacs Lisp code for customizing Emacs, and it's really fun to see
your Emacs "evolves" gradually.

It's worth to review again. To read most of Lisp code, it is easy. You
only need to these rules:

- Code that get executed is a pair of parentheses, with things in
in it: =(...)=. The first element always gets evaluated; your Lisp
environment (in our case, Emacs) determinse which of the following
3 forms the symbol in the first slot is, then acts accordingly:

+ Function form: if the first element points to a function definition,
  then the following elements get evaluated from left to right and
  finally passed into the function as arguments.

  For example:

  #+begin_src emacs-lisp
  age "Hello word %d" (+ 10 10))
  #+end_src

  =message= is a function that prints to echo area and =*Message*=
  buffer (can be opened with *C-h e*). Emacs detects that =message= is a
  function, then it evaluates the string "Hello world %d" and another
  nested form =(+ 10 10)= sequentially. When Emacs gets to =(+ 10
  10)=, it evaluates the form and return =20=. Then the string "Hello
  world %d" and the number =20= are passed into =message=, and finally
  output "Hello world 20" in the echo area and =*Message*= buffer.

+ Special form: if the first element is one of predefined functions in
  Emacs Lisp that need special rules and/or syntax, then the remaining
  elements are evaluated depend on the rule of the predefined
  functions. Special form is just function form, but handle the
  remaining in its own way rather than using the default in function
  form. That's why we call it special. 

  For example, =if= is a special form as we learned in previous part:

  #+begin_src emacs-lisp
    (if condition
        true-case
      false-case)
  #+end_src

  =condition= is a valid Lisp form; if it is evaluated to true (which
  is anything not =NIL=, or the empty list =()=), then the true case -
  also a valid Lisp form - gets evaluated; otherwise the false case -
  also a valid Lisp form - gets evaluated.

  Another special form is =and=. After Emacs determines the first
  element is =and= special form, then it keeps evaluating the
  remaining elements from left to right until one of the element
  return false. If all elements get evaluated, =and= returns true.

+ Macro form: if the first element is created by the function
  =defmacro= (which you do not need to know at this stage), then Emacs
  do not evaluate any remaining elements, but passes them in as
  data. Macro is a way for programmers to create their own
  mini-language that do not follow the evaluation rules predefined in
  Emacs (function form and special form). If you read a form that is
  not a function form or any predefined special form, don't panic!
  It's a macro form. Programmers always provide documentations on how
  to use their mini-languages.

After all, those different forms are just under one category:
function. Function form is a regular function; special form is a
function with its own rule; macro form is a function that generate
code.

- Data: has two types:

+ *Atom*: primites such as number, string, symbol and NIL.

+ *Non-atom*: if you put a =’= just before a form, it becomes
  a list. Emacs treats these *quoted* forms as data.

  Emacs also has other data types like array, hash-table... but list
  is the most popular, used when performance is not needed.

In this section, I only explained the frequently used functions. In
the later sections, there are more functions used. I can't explain
them all. You should really work it out on your own gradually with
*C-h f* and *C-h v*.
  
** Function: *(setq [ /SYM/ /VAL/ ]...)*
:PROPERTIES:
:ID:       efdf75c7-0278-46ab-910c-fd557d0584e9
:END:
  *_Comment_*: A really fundamental function for customizing Emacs
  settings. An Emacs setting is really just a variable. Emacs has GUI
  for changing setting, but =setq= a variable is also equivalent.

  *_Example_*:
  #+begin_src emacs-lisp
    (setq global-mark-ring-max 50000)
  #+end_src

  *_Built-in Documentation_*:
  #+BEGIN_QUOTE
  Set each /SYM/ to the value of its /VAL/.
  The symbols /SYM/ are variables; they are literal (not evaluated).
  The values /VAL/ are expressions; they are evaluated.
  Thus, (setq x (1+ y)) sets `x' to the value of `(1+ y)'.
  The second /VAL/ is not computed until after the first /SYM/ is set, and so on;
  each VAL can use the new value of variables set earlier in the `_setq_'.
  The return value of the `_setq_' form is the value of the last /VAL/.
  #+END_QUOTE

** Function: *(load /FILE/ &optional /NOERROR/ /NOMESSAGE/ /NOSUFFIX/ /MUST-SUFFIX/)*
:PROPERTIES:
:ID:       554a5d52-623c-487d-9e9b-81c5f8f67746
:END:
  *_Comment_*: This function allows you to load a file. /FILE/ is the
  a filename that is looked up in the Varable =load-path=. Do you
  notice =&optional= keyword? When you see this keyword, it means
  everything after =&optional= is, optional. The parameters /NOERROR/,
  /NOMESSAGE/, /NOSUFFIX/, /MUST-SUFFIX/ are not required to be passed
  into the function if you don't need. However, if you want to pass an
  argument into the place of one a parameter, you must also pass
  arguments to all the parameters to the left of your chosen
  parameter. For example, if you want to pass an argument into
  /NOSUFFIX/, you are *required* to pass arguments into /NOERROR/,
  /NOMESSAGE/ first. You are safe to ignore everything after your
  chosen parameter, and in our example, it's /MUST-SUFFIX/.

  *_Example_*: 

  #+begin_src emacs-lisp
    (load (substitute-in-file-name "$HOME/.emacs.d/module")) ;; first try to load module.elc; if not found, try to load module.el
    (load (substitute-in-file-name "$HOME/.emacs.d/module.el")) ;; only load module.el
    (load (substitute-in-file-name "$HOME/.emacs.d/module.elc")) ;; only load module.elc
    (load "module") ; search for the file module.el or module.elc in variable load-path
  #+end_src
   
  *_Built-int Documentation_*:
   
  #+BEGIN_QUOTE
  Execute a file of Lisp code named FILE.
  First try FILE with `.elc' appended, then try with `.el', then try
  FILE unmodified (the exact suffixes in the exact order are determined
  by `load-suffixes').  Environment variable references in FILE are
  replaced with their values by calling `substitute-in-file-name'. This
  function searches the directories in `load-path'. 
   
  ....(*C-h f* for more information)...
  #+END_QUOTE
** Function: *(require /FEATURE/ &optional /FILENAME/ /NOERROR/)*
:PROPERTIES:
:ID:       6b51529d-424f-4735-84e6-c13a0818376b
:END:
*_Comment_*: If you install a package from =M-x list-packages=, to
load that package, use =(require 'installed-package)=.

*_Example_*: For example, you installed package =volatile-highlights=,
to load it:

#+begin_src emacs-lisp
  (require 'volatile-highlights)
#+end_src


*_Built-in Documentation_*:

#+BEGIN_QUOTE
If feature /FEATURE/ is not loaded, load it from /FILENAME/.
If /FEATURE/ is not a member of the list `features', then the feature
is not loaded; so load the file /FILENAME/.
If /FILENAME/ is omitted, the printname of /FEATURE/ is used as the file name,
and `load' will try to load this name appended with the suffix `.elc' or
`.el', in that order.  The name without appended suffix will not be used.
See `get-load-suffixes' for the complete list of suffixes.
If the optional third argument /NOERROR/ is non-nil,
then return nil if the file is not found instead of signaling an error.
Normally the return value is /FEATURE/.
The normal messages at start and end of loading /FILENAME/ are suppressed.
#+END_QUOTE
** Function: *(add-to-list /LIST-VAR/ /ELEMENT/ &optional /APPEND/ /COMPARE-FN/)*
:PROPERTIES:
:ID:       6d573c2c-768b-4233-b8c0-5796f0b23304
:END:
*_Comment_*: Add an element =ELEMENT= to a list named =LIST-VAR=.

*_Example_*:

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/personal") ; add personal to load-path,
                                                 ; so "load" function can search for files in it
#+end_src

*_Built-in Documentation_*:

#+BEGIN_QUOTE
Add /ELEMENT/ to the value of /LIST-VAR/ if it isn't there yet.
The test for presence of /ELEMENT/ is done with `equal', or with
/COMPARE-FN/ if that's non-nil.
If /ELEMENT/ is added, it is added at the beginning of the list,
unless the optional argument /APPEND/ is non-nil, in which case
/ELEMENT/ is added at the end.

The return value is the new value of /LIST-VAR/.

This is handy to add some elements to configuration variables,
but please do not abuse it in Elisp code, where you are usually
better off using `push' or `cl-pushnew'.

If you want to use `add-to-list' on a variable that is not
defined until a certain package is loaded, you should put the
call to `add-to-list' into a hook function that will be run only
after loading the package.  `eval-after-load' provides one way to
do this.  In some cases other hooks, such as major mode hooks,
can do the job.
#+END_QUOTE

** Function: *(add-hook /HOOK/ /FUNCTION/ &optional /APPEND/ /LOCAL/)*
:PROPERTIES:
:ID:       acb677cd-cad6-43c7-9bdb-b31578337fe0
:END:
*_Comment_*: A *hook* is a Lisp variable which holds a list of
functions, to be called on some well-defined occasion. (This is called
running the hook. You can search for hook using *C-h v* and enter
=-hook= suffix then *TAB*. Or you can find hooks in *Customization Groups*.

*_Example_*:

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'linum-mode)
#+end_src

After you add the function =linum-mode= - which activates line number
on the left margin of your Emacs - then every time you enter a
=prog-mode=, which is the root all programming major modes derive
from. A programming mode can be =c-mode=, =asm-mode=,
=emacs-lisp-mode=, =java-mode=...

*_Built-in Documentation_*:
#+BEGIN_QUOTE
Add to the value of HOOK the function /FUNCTION/.
/FUNCTION/ is not added if already present.
/FUNCTION/ is added (if necessary) at the beginning of the hook list
unless the optional argument /APPEND/ is non-nil, in which case
/FUNCTION/ is added at the end.

The optional fourth argument, /LOCAL/, if non-nil, says to modify
the hook's buffer-local value rather than its global value.
This makes the hook buffer-local, and it makes t a member of the
buffer-local value.  That acts as a flag to run the hook
functions of the global value as well as in the local value.

/HOOK/ should be a symbol, and /FUNCTION/ may be any valid function.  If
/HOOK/ is void, it is first set to nil.  If /HOOK/'s value is a single
function, it is changed to a list of functions.
#+END_QUOTE

** Function: *(global-set-key /KEY/ /COMMAND/)*
:PROPERTIES:
:ID:       5c06ee7d-fb65-48bb-8419-c5660d4d4fd2
:END:
*_Comment_*: This function binds a command to a key, as you can see in
the function interface.
   
*_Example_*:

You can bind in one of the following ways:
   
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer) ;; bind "C-x C-b" to ibuffer command
  (global-set-key "\C-x\C-b" 'ibuffer)  ;; bind "C-x C-b to ibuffer command, but modifier 
                                        ;; keys must be escaped with the backslash
  (global-set-key [?\C-x?\C-b] 'ibuffer) ;; use vector instead of a string
#+end_src
   
I recommend you to use =(kbd ...)= function because we can write key
bindings using our familiar key notations without adding unnecessary
characters. Vector is array in other languags. Vector was used for
mapping function keys, such as =[left]=, =[right]=, =[up]=, =[down]=,
=[f1]...[f12]=. But now, you can also map function keys in =(kbd
...)= function using angle brackets:
 
#+begin_src emacs-lisp
  (global-set-key (kbd "<f3>") 'kmacro-start-macro-or-insert-counter)
#+end_src
 
Here are common function keys (remember to wrap them in a pair of
angle bracket):
 
| Key                                              | Description                                        |
|--------------------------------------------------+----------------------------------------------------|
| =left, up, right, down=                          | Cursor arrow keys                                  |
|--------------------------------------------------+----------------------------------------------------|
| =begin, end, home, next, prior=                  | Other cursor repositioning keys                    |
|                                                  | =prior= means =PageUp=                             |
|                                                  | =next= means =PageDOwn=                            |
|--------------------------------------------------+----------------------------------------------------|
| =select, print, execute, backtab=                | Miscellaneous keys                                 |
| =insert, undo, redo, clearline=                  | =backtab= means =S-TAB= or =C-iso-tab=             |
| =insertline, deleteline, insertchar, deletechar= |                                                    |
|--------------------------------------------------+----------------------------------------------------|
| =f1, f2, ... F35=                                | Numbered function keys on top of your keyboard     |
|--------------------------------------------------+----------------------------------------------------|
| =kp-add, kp-subtract, kp-multiply, kp-divide=    | Keypad keys (to the right of the regular keyboard) |
| =kp-backtab, kp-space, kp-tab, kp-enter=         | , with names or punctuation.                       |
| =kp-separator, kp-decimal, kp-equal=             |                                                    |
|                                                  |                                                    |
| =kp-0, kp-1, ... kp-9=                           | Keypad keys with digits.                           |
|                                                  |                                                    |
| =kp-f1, kp-f2, kp-f3, kp-f4=                     | Keypad PF keys.                                    |
|--------------------------------------------------+----------------------------------------------------|
 
*_Built-in Documentation_*:
 
#+BEGIN_QUOTE
Give /KEY/ a global binding as /COMMAND/.
/COMMAND/ is the command definition to use; usually it is
a symbol naming an interactively-callable function.
/KEY/ is a key sequence; noninteractively, it is a string or vector
of characters or event types, and non-ASCII characters with codes
above 127 (such as ISO Latin-1) can be included if you use a vector.
 
Note that if /KEY/ has a local binding in the current buffer,
that local binding will continue to shadow any global binding
that you make with this function.
#+END_QUOTE
** Function: *(define-key /KEYMAP/ /KEY/ /DEF/)*
:PROPERTIES:
:ID:       879a92aa-5c2b-4623-913a-45dddb84ed7b
:END:
*_Comment_*: 

This function binds a definition =DEF=, usually a command, to a key
sequence =KEY=. A definition can be other things that you can find in
the built-in documentation.

A key sequence (key, for short) is a sequence of input events that
have a meaning as a unit. Input events include characters, function
keys and mouse buttons—all the inputs that you can send to the
computer. A key sequence gets its meaning from its binding, which says
what command it runs.

When a key sequence =KEY= is pressed, Emacs runs the associated
function. A keymap =KEYMAP= stores a list of bindings between =KEY=
and definition =DEF=. Major mode or minor mode uses keymap to provide
its own key bindings. A keymap usually has =-mode-map= suffix,
i.e. dired-mode-map; if you want to change or add a key binding in a
major mode or minor mode, you use =define-key= function like this:

*_Example_*:

#+begin_src emacs-lisp
  ;; Dired uses "e", "f" or RET to open a file
  ;; you can reuse one of these keys for different purpose
  ;; for example, you can bind it to wdired-change-to-wdired-mode
  ;; wdired-change-to-wdired-mode allows you to edit your Dired buffer
  ;; like a normal text buffer, such as edit file/directory names,
  ;; permission bits.. and then commit the changes to disk.
  ;;
  ;; "e" is short for "edit"
  ;; After finish your editing, "C-c C-c" to commit, "C-c C-k" to abort
  (define-key dired-mode-map (kbd "e") 'wdired-change-to-wdired-mode)
#+end_src

*_Built-in Documentation_*:

#+BEGIN_QUOTE
In /KEYMAP/, define key sequence /KEY/ as /DEF/.
/KEYMAP/ is a keymap.

/KEY/ is a string or a vector of symbols and characters, representing a
sequence of keystrokes and events.  Non-ASCII characters with codes
above 127 (such as ISO Latin-1) can be represented by vectors.
Two types of vector have special meanings:
[remap COMMAND] remaps any key binding for /COMMAND/.
[t] creates a default definition, which applies to any event with no
other definition in /KEYMAP/.

/DEF/ is anything that can be a key's definition:
nil (means key is undefined in this keymap),
a command (a Lisp function suitable for interactive calling),
a string (treated as a keyboard macro),
a keymap (to define a prefix key),
a symbol (when the key is looked up, the symbol will stand for its
               function definition, which should at that time be one of the above,
               or another symbol whose function definition is used, etc.),
a cons (STRING . DEFN), meaning that DEFN is the definition
(DEFN should be a valid definition in its own right),
or a cons (MAP . CHAR), meaning use definition of CHAR in keymap MAP,
or an extended menu item definition.
(See info node `(elisp)Extended Menu Items'.)

If /KEYMAP/ is a sparse keymap with a binding for /KEY/, the existing
binding is altered.  If there is no binding for /KEY/, the new pair
binding /KEY/ to /DEF/ is added at the front of /KEYMAP/.
#+END_QUOTE
** Macro: *(defun /NAME/ /ARGLIST/ &optional /DOCSTRING/ /DECL/ &rest /BODY/)*
:PROPERTIES:
:ID:       0d30e7ca-7282-441e-868b-0b07ce2eaf70
:END:
*_Comment_*: defun is a Lisp macro that allows you to define a
function, like any other language. A function is a collection of
Lisp forms to be executed. The return value is the last form.

*_Example_*:

- Create a normal function (Not available in =M-x=):

#+begin_src emacs-lisp
  (defun demo ()
    (message "Hello World" number string))
#+end_src

- Create a command (Available in =M-x=):
#+begin_src emacs-lisp
  (defun demo ()
    (interactive)
    (message "Hello World"))
#+end_src

=interactive= is a special form that turns a function into a command
and allow a command to accept various types of prefix arguments, such
as a number, a string, symbol, buffer names... You can *C-h f* and
type =interactive= to find out more.

*_Built-in Documentation_*:
#+BEGIN_QUOTE
Define /NAME/ as a function.
The definition is (lambda /ARGLIST/ [/DOCSTRING/] /BODY/...).
See also the function `interactive'.
/DECL/ is a declaration, optional, of the form (declare /DECLS...) where
/DECLS/ is a list of elements of the form (/PROP/ . /VALUES/).  These are
interpreted according to `defun-declarations-alist'.
The return value is undefined.
#+END_QUOTE

* Useful built-in key bindings for navigating pairs
:PROPERTIES:
:ID:       7522b365-52f4-4fa9-b316-7843b772c59a
:END:

|-------------+------------------------------------------|
| =C-M-f=     | *Command*: =forward-sexp=                |
|             | Move forward over a balanced expression  |
|             | ...[screenshot]...                       |
|-------------+------------------------------------------|
| =C-M-b=     | *Command*: =backward-sexp=               |
|             | Move backward over a balanced expression |
|             | ...[screenshot]...                       |
|-------------+------------------------------------------|
| =C-M-k=     | *Command*: =kill-sexp=                   |
|             | Kill balanced expression forward         |
|             | ...[screenshot]...                       |
|-------------+------------------------------------------|
| =C-M-t=     | *Command*: =transpose-sexps=             |
|             | Transpose expressions                    |
|             | ...[screenshot]...                       |
|-------------+------------------------------------------|
| =C-M-<SPC>= | *Command*: =mark-sexp=                   |
| =C-M-@=     | Put mark after following expression      |
|             | ...[screenshot]...                       |
|-------------+------------------------------------------|

* Let's supercharge Emacs
:PROPERTIES:
:ID:       7b18379f-81e9-4c8f-8aab-9b8acaccdb26
:END:
Throughout this section I will help you to extend Emacs with packages
that improves general Emacs features, such as Info, Dired, buffer
management... I will introduce you popular packages out there, but I
cannot present you all. The purpose of this guide is to help you get
really comfortable to Emacs package system, so you can extend Emacs
with packages from other people easily to fit your need. Writing your
own Emacs extension is a differnt story, and is beyond the scope of
this guide.

I will introduce packages specialized for programming in later part: how
to setup programming environment for popular languages (C/C++, Lisp,
Python, Ruby...); each programming environment will have its own
chapter. In this part of the mini manual series, I only introduce
general packages for extending Emacs in various aspects. And you are
going to need some of these packages to setup your specialized
programming envrionment, so don't skip it.

Don't be intimidated if you see many packages down there. Adding
packages and see it extends your Emacs is fun and addictive, like 
playing video games.

To remind you, Emacs always loads one of the three of the following
files when it starts:

- ~/.emacs
- ~/.emacs.d/init
- ~/.emacs.d/init.el

To apply a setting, move point to the end of a Lisp expression and
*C-x C-e*, which runs =eval-last-sexp=.

When you want to complete function names in Emacs Lisp: *C-M-i*,
which runs =completion-at-point=. It will display a list of possible
candidates available in Emacs. As a reminder, if you want to quickly
complete some text, you can *M-/*, which runs =dabbrev-expand=. 

If a package uses new functions, I will introduce the functions in its
own sections just before we get to that package. I will only introduce
the basic usage of the functions. If you want to understand more, *C-h
f* and enter name of the function. All of the quoted function
descriptions are taken from *C-h f*. If you forget what a function
does and how to use it, *C-h f* to find out. Really, you should get
used to getting help from Emacs itself.

** How to use Emacs package manager
:PROPERTIES:
:ID:       06a338f7-bc33-47fe-8dca-f8bb9fac64ac
:END:
Emacs has a package manager to make the task of installing, update and
removing easier, as well as inform users new packages created by the
community. Emacs gets a list of packages from sources, called package
archive. Package archive is the same as repository in
Linux. Currently, there are 3 package archives in Emacs: 

- built-in: limited number of packages, and not always up to date.
- Marmalade: more packages, but mostly outdated since people moved to MELPA.
- MELPA: the most popular and most up to date package archive, with
  most number of packages.

Marmalade and MELPA are not activated by default; you have to add them
manually. You only need to setup MELPA and that's enough to get all
the packages described in later sections. Add this code snippet to your
=~/.emacs.d/init.el=:

#+begin_src emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
    '("melpa" . "http://melpa.milkbox.net/packages/") t)
#+end_src

Then, evaluate those two expressions with *C-x C-e* or =eval-buffer=.

To open the package manager, =M-x list-package=. You will see a list
of packages. 

- To navigate the package list down and up using *n* and *p*. 
- To view information of a package, press *RET*. 
- To mark a package for install, press *i*.
- To mark a package for delete, press *d*.
- To unmark a package, press *u*.
- To execute the marked packages (either for install or delete), press *x*.
- To referesh and update the lastest package list, press *r*.
- To display these key bindings, press *h*.

That's that.

*_Exercise_*: Let's install a few packages in advance, so you won't
have to install the packages later. Install these packages:

- volatile-highlights
- clean-aindent-mode
- undo-tree
- yasnippet
- rebox2

** Customize Emacs
:PROPERTIES:
:ID:       9a5a1fd7-1763-4de2-935e-b21f107a023b
:END:
*** Using GUI
:PROPERTIES:
:ID:       a5d94712-f14d-4b1d-9780-f40a20606813
:END:
If you want to change a specific setting, you need to change a
variable value. You wonder, there are so many variables to set. How do
you know which to which? Luckily, you don't have to manually guess
which variable to set. Emacs has a command for setting Emacs
internally, with a nice organization of settings, rather than randomly
set a variable that you randomly found. =M-x customize= to open a
window for customizing Emacs:

...[screenshol]...

You will see various categories for customizing Emacs. These
categories are called *Customization Groups* in Emacs. Let's try
setting something in Emacs: 

- Go to *Editing* -> *Editing Basics* -> move point to "Global
Mark ring Max: ".
- Change the value to 5000.
- Move point on *State* button. Press *RET*.
- A menu appears with the following choice:

=0 = Set for current Sesssion=
This option is for trying out a new setting. If you close Emacs, the
old setting is restored.

=1 = Save for Future Sesssions=
This option saves the new value permanently, so the next time you
start Emacs, it uses your saved setting. The new value is saved at
=~/.emacs.d/init.el= like this:

#+begin_src emacs-lisp
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(global-mark-ring-max 5000))
#+end_src

=2 = Undo Edits=
Undo to the previous value of a particular setting, if you haven't
set.

=3 = Revert This Sesssion's Customization=
This restores the value of the variable to the last saved value, and
updates the text accordingly.

=4 = Erase Customization=
Reset to standard value and delete set value in =~/emacs.d/init.el=.

=7 = Add Comment=
Someimtes you have something to say about your customization. Write it
using this option. You customized variable will have 

=: = Show Saved Lisp Expression=
Show the actual variable representation. If you open the menu again,
the option =: = Show Saved Lisp Expression= is changed to =Show
current value= that switches back to the nicer representation.

Another way to change a setting is using *C-h v*, which runs
=describe-variable= that list all the avaialble variables in your
Emacs and allow you to select one. You can also access the parent
group of a group or a variable.

Aside from the general =customize= command, Emacs has many more
customization command: =customize-group=, =customize-face=... That
organize customization groups in different ways. However, in the scope
of this guide, we only use =customize= for customize Emacs generally
and =customize-group= to select a specific package for customizing,
and also find out which parent group the package belongs to.

*** Using Emacs Lisp
:PROPERTIES:
:ID:       24fade09-4735-4f0b-ba82-5742d3b5a314
:END:
The above approach uses GUI, which makes Emacs look familar to normal
users from other editors: using GUI to change the editors. However, it
has disadvantages: Monolithic. Although the settings are nicely
organized into groups, its underlying representation is not. After you
set and save something in whatever group, Emacs always add your
setting to the function =custom-set-variables= like this:

#+begin_src emacs-lisp
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(global-mark-ring-max 5000 nil nil "test"))
#+end_src

As you can read it the comment, =custom-set-variables= is expected to
be unique in your init file. If you have more, things go wrong. So, by
design, you cannot split the settings into logical groups of your
choice.

For that reason, =setq= is the preferred method. But, you can use the
GUI with nice and logical grouping to guide you to the settings you
want to change. The grouping is nice, and for consistency, we should
organize our module structure based on the grouping in =M-x
customize=:

- setup-editing.el for =Editing= group.
- setup-convenience.el for =Convenience= group.
- setup-files.el for =Files= group.
- setup-text.el for =Text= group.
- setup-data.el for =Data= group.
- setup-external.el for =External= group.
- setup-communication.el for =Communication= group.
- setup-programming.el for =Programming= group.
- setup-applicationss.el for =Application= group.
- setup-development.el for =Development= group.
- setup-environment.el for =Environment= group.
- setup-faces.el for =Faces= group.
- setup-help.el for =Help= group.
- setup-multimedia.el for =Multimedia= group.
- setup-local.el for =Local= group.

*_Exercise_*: 

- Create a directory: =~/.emacs.d/custom/=
- Create the above =setup-*.el= files under it.
- For each file, add its appropriate group. Add a comment at start of
  each file, noting which group this file belongs to. For example:

  #+begin_src emacs-lisp
    ;,--------------------------------------
    ;| MAIN GROUP: Editing
    ;`--------------------------------------
  #+end_src
  
You already installed the package =rebox2= in [[*How%20to%20use%20Emacs%20package%20manager][How to use Emacs package
manager]] section. When you mark a region and *M-q*, you can create the
above comment box. There are many styles, you can cycle by pressing
*M-q* repeatedly.

Now, everything is prepared. We can really dive into customizing and
extending Emacs with 3rd party packages and various code snippets that
solve many little problems. In later sections, each is dedicated to a
category. But, please note that I only provide the customizations that
I found useful, not some template that you have to follow rigidly. You
can consider my customizations as an example for your own
customizations. You can use it either way:

- Copy the sample configurations into your files and look back later
  or just don't care.

- Really control the customization process and make the customizations
  actually yours, by reading the customization code and understand
  what it does.

** setup-editing.el
:PROPERTIES:
:ID:       bd536b4e-fdcf-465c-af88-d86c36502c8a
:END:

  Let's use =setq= to change Emacs the way we want. You should type in
  the snippet below and use the completion key bindings until you get
  used to it.

  #+begin_src emacs-lisp
    ;,--------------------------------------
    ;| MAIN GROUP: Editing
    ;`--------------------------------------

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; GROUP: Editing -> Editing Basics   ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; you can set a value to one variablea
    (setq
     global-mark-ring-max 5000
     mark-ring-max 5000
     mode-require-final-newline t
     tab-width 4)

    (delete-selection-mode)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; GROUP: Editing -> Electricity      ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;
    ;; you can see these variables Eletricity group. However, these variables
    ;; are not for setting because setting them have no effect. You have to activate
    ;; command of the same name. If some variables are required to be activated through
    ;; commands, the description of those variables explicitly say so.
    (electric-indent-mode) ;; activate automatic indent when press RET
    (electric-pair-mode) ;; activate automatic paring

    ;; an example of association list, also an example of how to write a character
    ;; add more pairs if you want
    ;; (setq electric-pair-pairs '(( ?\< . ?\>)))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; GROUP: Editing -> Killing          ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (setq
     kill-ring-max 5000 ;; increase kill-ring capacity
     kill-whole-line t  ;; if NIL, kill whole line and move the next line up
     )

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; GROUP: Editing -> Matching         ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; As you can see, I only use a single option in the inner sub-group
    ;; It's not worth to create a file
    (setq show-paren-delay 0) ; highlight parentheses immediately
    (show-paren-mode) ; activate show-paren-mode
  #+end_src
*** Customize built-in functions
:PROPERTIES:
:ID:       a46d3a98-d481-41a3-8b15-50eb98c2e4ac
:END:
Sometimes, we want to adjust or improve the behaviours of some
commands in certain contexts. Consider this situataion: *C-a*, whicn
runs =move-beginning-of-line=, always move to the beginning of
line. However, sometimes we don't always to move to the beginning of 
line, but move to the first non-whitespace character of that line.

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Customized functions                ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defun prelude-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first. If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  (global-set-key [remap move-beginning-of-line] 'prelude-move-beginning-of-line)

  (defadvice kill-ring-save (before slick-copy activate compile)
    "When called interactively with no active region, copy a single
  line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (message "Copied line")
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single
    line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  ;; kill a line, including whitespace characters until next non-whiepsace character
  ;; of next line
  (defadvice kill-line (before check-position activate)
    (if (member major-mode
                '(emacs-lisp-mode scheme-mode lisp-mode
                                  c-mode c++-mode objc-mode
                                  latex-mode plain-tex-mode))
        (if (and (eolp) (not (bolp)))
            (progn (forward-char 1)
                   (just-one-space 0)
                   (backward-char 1)))))

  ;; taken from prelude-editor.el
  ;; automatically indenting yanked text if in programming-modes
  (defvar yank-indent-modes
    '(LaTeX-mode TeX-mode)
    "Modes in which to indent regions that are yanked (or yank-popped).
  Only modes that don't derive from `prog-mode' should be listed here.")

  (defvar yank-indent-blacklisted-modes
    '(python-mode slim-mode haml-mode)
    "Modes for which auto-indenting is suppressed.")

  (defvar yank-advised-indent-threshold 1000
    "Threshold (# chars) over which indentation does not automatically occur.")

  (defun yank-advised-indent-function (beg end)
    "Do indentation, as long as the region isn't too large."
    (if (<= (- end beg) yank-advised-indent-threshold)
        (indent-region beg end nil)))

  (defadvice yank (after yank-indent activate)
    "If current mode is one of 'yank-indent-modes,
  indent yanked text (with prefix arg don't indent)."
    (if (and (not (ad-get-arg 0))
             (not (member major-mode yank-indent-blacklisted-modes))
             (or (derived-mode-p 'prog-mode)
                 (member major-mode yank-indent-modes)))
        (let ((transient-mark-mode nil))
          (yank-advised-indent-function (region-beginning) (region-end)))))

  (defadvice yank-pop (after yank-pop-indent activate)
    "If current mode is one of `yank-indent-modes',
  indent yanked text (with prefix arg don't indent)."
    (when (and (not (ad-get-arg 0))
               (not (member major-mode yank-indent-blacklisted-modes))
               (or (derived-mode-p 'prog-mode)
                   (member major-mode yank-indent-modes)))
      (let ((transient-mark-mode nil))
        (yank-advised-indent-function (region-beginning) (region-end)))))

  ;; prelude-core.el
  (defun prelude-duplicate-current-line-or-region (arg)
    "Duplicates the current line or region ARG times.
  If there's no region, the current line will be duplicated. However, if
  there's a region, all lines that region covers will be duplicated."
    (interactive "p")
    (pcase-let* ((origin (point))
                 (`(,beg . ,end) (prelude-get-positions-of-line-or-region))
                 (region (buffer-substring-no-properties beg end)))
      (-dotimes arg
        (lambda (n)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point))))
      (goto-char (+ origin (* (length region) arg) arg))))

  ;; prelude-core.el
  (defun prelude-indent-buffer ()
    "Indent the currently visited buffer."
    (interactive)
    (indent-region (point-min) (point-max)))

  ;; prelude-core.el
  (defun prelude-cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer."
    (interactive)
    ;; (prelude-untabify-buffer) ;; leave the buffer format alone
    (prelude-indent-buffer)
    (whitespace-cleanup))

  (global-set-key (kbd "C-c i") 'prelude-cleanup-buffer)

  ;; add duplicate line function from Prelude
  ;; taken from prelude-core.el
  (defun prelude-get-positions-of-line-or-region ()
    "Return positions (beg . end) of the current line
  or region."
    (let (beg end)
      (if (and mark-active (> (point) (mark)))
          (exchange-point-and-mark))
      (setq beg (line-beginning-position))
      (if mark-active
          (exchange-point-and-mark))
      (setq end (line-end-position))
      (cons beg end)))

  (defun prelude-duplicate-current-line-or-region (arg)
    "Duplicates the current line or region ARG times.
  If there's no region, the current line will be duplicated. However, if
  there's a region, all lines that region covers will be duplicated."
    (interactive "p")
    (pcase-let* ((origin (point))
                 (`(,beg . ,end) (prelude-get-positions-of-line-or-region))
                 (region (buffer-substring-no-properties beg end)))
      (-dotimes arg
        (lambda (n)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point))))
      (goto-char (+ origin (* (length region) arg) arg))))

  (global-set-key (kbd "M-c") 'prelude-duplicate-current-line-or-region)
#+end_src

The code above is taken from this article: [[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][Smarter Navigation to the
Beginning of a Line]].

#+begin_src emacs-lisp
  (defadvice kill-ring-save (before slick-copy activate compile)
    "When called interactively with no active region, copy a single
  line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (message "Copied line")
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single
    line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  ;; kill a line, including whitespace characters until next non-whiepsace character
  ;; of next line
  (defadvice kill-line (before check-position activate)
    (if (member major-mode
                '(emacs-lisp-mode scheme-mode lisp-mode
                                  c-mode c++-mode objc-mode
                                  latex-mode plain-tex-mode))
        (if (and (eolp) (not (bolp)))
            (progn (forward-char 1)
                   (just-one-space 0)
                   (backward-char 1)))))

#+end_src

*** Package: =volatile-highlights=
:PROPERTIES:
:ID:       f8441653-b68d-4c18-8eb4-28ceff5739fc
:END:
*_Author_*: Keitalo Miyazaki, =Keitaro.Miyazaki@gmail.com=

*_Homepage_*: [[http://www.emacswiki.org/emacs/VolatileHighlights][Emacswiki]]

*_Features_*:

VolatileHighlights highlights changes to the buffer caused by commands
such as ‘undo’, ‘yank’/’yank-pop’, etc. The highlight disappears at
the next command. The highlighting gives useful visual feedback for
what your operation actually changed in the buffer.

*_Installation_*:

=M-x list-packages= and select *volatile-highlights* package, then
install it. After finish installing, add this code snippet to activate
the package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Package: volatile-highlights          ;;
  ;;                                       ;;
  ;; GROUP: Editing -> Volatile Highlights ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'volatile-highlights)
  (volatile-highlights-mode t)
#+end_src

*_Usage_*: 

When you yank (paste) something, the yanked (pasted) region will be
highlighted.

*** Package: =clean-aindent-mode=
:PROPERTIES:
:ID:       49958ce7-6af0-47ac-b309-6ea75833f0e1
:END:
*_Author_*: [[https://github.com/pmarinov][Peter Marinov]]

*_Homepage_*: [[https://github.com/pmarinov/clean-aindent-mode][Github]]

*_Features_*:

When you press *RET* to create a newline and got indented by
=eletric-indent-mode=, you have appropriate whitespace for
indenting. But, if you leave the line blank and move to the next line,
the whitespace becomes useless. This package helps clean up unused
whitespace.

View this [[http://www.emacswiki.org/emacs/CleanAutoIndent][Emacswiki page]] for more details.

*_Installation_*:
=M-x list-packages= and select *clean-aindent-mode* package, then
install it. After finish installing, add this code snippet to activate
the package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Package: clean-aindent-mode               ;;
  ;;                                           ;;
  ;; GROUP: Editing -> Indent -> Clean Aindent ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'clean-aindent-mode)
#+end_src

*_Usage_*: 

Automatically cleanup useless whitepsace on moving up/down.

*** Package: =undo-tree=
:PROPERTIES:
:ID:       03030916-bb5c-4966-8fa1-68807b60bec2
:END:
*_Author_*: Toby Cubitt, =toby-undo-tree@dr-qubit.org=

*_Homepage_*: [[http://www.dr-qubit.org/emacs.php#undo-tree][www.dr-qubit.org]]

*_Features_*: 

=undo-tree= allows you to visual the whole history of your editing in
a tree. It also provides regular undo/redo behaviours in other
editors. =undo-tree= can even provide a diff between two different states. Highly recommended. 

...[screenshot]...

*_Installation_*:
=M-x list-packages= and select *undo-tree* package, then
install it. After finish installing, add this code snippet to activate
the package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Package: undo-tree                  ;;
  ;;                                     ;;
  ;; GROUP: Editing -> Undo -> Undo Tree ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'undo-tree)
  (global-undo-tree-mode)
#+end_src

*_Usage_*:

From now on, your undo (*C-/*) behaves just like normal editor. To
redo, *C-_*. To open the undo tree, *C-x u*.

*** Package: =yasnippet=
:PROPERTIES:
:ID:       bb1ea352-f9ea-47fe-bb3e-5727e542c481
:END:
*_Author_*: [[https://github.com/capitaomorte][João Távora]]

*_Homepage_*: [[https://github.com/capitaomorte/yasnippet][Github]]

*_Features_*:

YASnippet is a template system for Emacs. It allows you to type an
abbreviation and automatically expand it into function
templates. Bundled language templates include: C, C++, C#, Perl,
Python, Ruby, SQL, LaTeX, HTML, CSS and more. The snippet syntax is
inspired from TextMate's syntax, you can even import most TextMate
templates to YASnippet.

*_Installation_*:
=M-x list-packages= and select *yasnippet* package, then
install it. After finish installing, add this code snippet to activate
the package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Package: yasnippet                 ;;
  ;;                                    ;;
  ;; GROUP: Editing -> Yasnippet        ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'yasnippet)
  (yas-global-mode 1)
#+end_src

*_Usage_*: In major modes where *yasnippet* has snippets available,
typing a certain keyword and *TAB* insert a predefined snippet. For
example, in a C buffer, if you type =for= and *TAB*, it expands to:

#+begin_src c
  for (i = 0; i < N; i++) {
      ...point will be here....
  }
#+end_src

You can view supported snippets [[https://github.com/AndreaCrotti/yasnippet-snippets/tree/master][here]].

** setup-convenience.el
:PROPERTIES:
:ID:       475adb79-c675-457d-b1ae-b0540313d642
:END:
Here is my sample customization:

#+begin_src emacs-lisp
  ;;
  ;; MAIN GROUP: Convenience
  ;;

  ;; GROUP: Convenience -> Revert

  ;; update any change made on file to the current buffer
  (global-auto-revert-mode)

  ;; GROUP: Convenience -> Hippe Expand
  ;; hippie-expand is a better version of dabbrev-expand.
  ;; While dabbrev-expand searches for words you already types, in current;; buffers and other buffers, hippie-expand includes more sources,
  ;; such as filenames, klll ring...
  (global-set-key (kbd "M-/") 'hippie-expand) ;; replace dabbrev-expand
  (setq
   hippie-expand-try-functions-list
   '(try-expand-dabbrev ;; Try to expand word "dynamically", searching the current buffer.
     try-expand-dabbrev-all-buffers ;; Try to expand word "dynamically", searching all other buffers.
     try-expand-dabbrev-from-kill ;; Try to expand word "dynamically", searching the kill ring.
     try-complete-file-name-partially ;; Try to complete text as a file name, as many characters as unique.
     try-complete-file-name ;; Try to complete text as a file name.
     try-expand-all-abbrevs ;; Try to expand word before point according to all abbrev tables.
     try-expand-list ;; Try to complete the current line to an entire line in the buffer.
     try-expand-line ;; Try to complete the current line to an entire line in the buffer.
     try-complete-lisp-symbol-partially ;; Try to complete as an Emacs Lisp symbol, as many characters as unique.
     try-complete-lisp-symbol) ;; Try to complete word as an Emacs Lisp symbol.
   )

  ;; GROUP: Convenience -> HL Line
  (global-hl-line-mode)

  ;; GROUP: Convenience -> Ibuffer
  (setq ibuffer-use-other-window t) ;; always display ibuffer in another window

  ;; GROUP: Convenience -> Linum
  (add-hook 'prog-mode-hook 'linum-mode) ;; enable linum only in programming modes

  ;; GROUP: Convenience -> Whitespace

  ;; whenever you create useless whitespace, the whitespace is highlighted
  (add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))

  ;; activate whitespace-mode to view all whitespace characters
  (global-set-key (kbd "C-c w") 'whitespace-mode)

  ;; GROUP: Convenience -> Windmove

  ;; easier window navigation
  (windmove-default-keybindings)
#+end_src

*** Package: =company=
:PROPERTIES:
:ID:       613a1da4-4b5b-4c50-9c9d-8152d1a4bad9
:END:
*_Author_*: 

- Nikolaj Schumacher (original author)
- [[https://github.com/dgutov][Dmitry Gutov]] (current maintainer), =dgutov@yandex.ru=

*_Homepage_*: [[http://company-mode.github.io/]]

*_Features_*:

Company is a text completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to
retrieve and display completion candidates.

It comes with several back-ends such as =Elisp=, =Clang=, =Semantic=, =Eclim=,
=Ropemacs=, =Ispell=, =CMake=, =BBDB=, =Yasnippet=, =dabbrev=, =etags=, =gtags=,
=files=, =keywords= and a few others.

The CAPF back-end provides a bridge to the standard
completion-at-point-functions facility, and thus works with any major
mode that defines a proper completion function.

*_Installation_*:

=M-x list-packages= and select *company* package, then
install it. After finish installing, add this code snippet to activate
the package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: company              ;;
  ;;                               ;;
  ;; GROUP: Convenience -> Company ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (add-hook 'after-init-hook 'global-company-mode)
#+end_src

*_Usage_*:

Completion will start automatically after you type a few letters. Use
*M-n* and *M-p* to select, *<return>* to complete or *<tab>* to complete the
common part. Search through the completions with *C-s*, *C-r* and
*C-o*. Press *M-(digit)* to quickly complete with one of the first 10
candidates.

*** Package: =expand-region=
:PROPERTIES:
:ID:       4c5acb48-c884-4720-a9c0-e25c2ee35296
:END:
*_Author_*: [[https://github.com/magnars][Magnar Sveen]]

*_Homepage_*: [[https://github.com/magnars/expand-region.el][Github]]

*_Features_*:
=expand-region= allows you to select text objects incrementally. 

..[screenshot]...

*_Installation_*:
=M-x list-packages= and select *expand-region* package, then
install it. After finish installing, add this code snippet to activate
the package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Package: expand-region                       ;;
  ;;                                              ;;
  ;; GROUP: Convenience -> Abbreviation -> Expand ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'expand-region)
  (global-set-key (kbd "M-m") 'er/expand-region)
#+end_src

I bind =er/expand-regin= to *M-m*, because the functionality is
included from the amended =beginning-of-line= we did above.

*_Usage_*: 

*M-m* to continue expand outward.

*** Package: =ibuffer-vc=
:PROPERTIES:
:ID:       7b0b29a2-6a13-4b39-bbec-bb52ff97783b
:END:
*_Author_*: [[https://github.com/purcell][Steve Purcell]]

*_Homepage_*: [[https://github.com/purcell/ibuffer-vc][Github]]

*_Features_*:

- Group your buffers by their parent vc root directory
- See the VC status of the associated files
- Sort buffers by their VC status

...[screenshot on homepage]...

*_Installation_*:
=M-x list-packages= and select *ibuffer-vc* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  (add-hook 'ibuffer-hook
            (lambda ()
              (ibuffer-vc-set-filter-groups-by-vc-root)
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                (ibuffer-do-sort-by-alphabetic))))

  (setq ibuffer-formats
        '((mark modified read-only vc-status-mini " "
                (name 18 18 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " "
                (vc-status 16 16 :left)
                " "
                filename-and-process)))
#+end_src

*_Usage_*: 

When you use =ibuffer=, it will automatically group buffers by version
control system.

*** Package: =rebox2=
:PROPERTIES:
:ID:       54921b8d-80fb-4b7d-b8d4-e47a90496af0
:END:
*_Author_*: [[https://github.com/lewang][Le Wang]]

*_Homepage_*: [[https://github.com/lewang/rebox2][Github]]

*_Features_*: 

Fancy box quoting I n comment.

- auto-fill boxes (install filladapt for optimal filling)
- motion (beginning-of-line, end-of-line) within box
- S-return rebox-newline
- kill/yank (within box) only text, not box borders
- move box by using space, backspace / center with M-c
- point has to be to the left of the border

*_Installation_*:
=M-x list-packages= and select *rebox2* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: rebox2             ;;
  ;;                             ;;
  ;; GROUP: Convenience -> Rebox ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'rebox2)
  (global-set-key [(meta q)] 'rebox-dwim)
  (global-set-key [(shift meta q)] 'rebox-cycle)
  (add-hook 'prog-mode-hook (lambda ()
                              (set (make-local-variable 'rebox-style-loop) '(25 17 21))
                              (set (make-local-variable 'rebox-min-fill-column) 40)
                              (rebox-mode 1)))
#+end_src

*_Usage_*:

- Mark a region.
- *M-q* to cycle between box styles.

*** Package: =projectile=
:PROPERTIES:
:ID:       f6ec9632-9fa5-477b-bf34-5975b760577a
:END:
*_Author_*: [[https://github.com/bbatsov][Bozhidar Batsov]], =bozhidar@batsov.com=

*_Homepage_*: [[https://github.com/bbatsov/projectile][Github]]

*_Features_*:

*Projectile* is a project interaction library for Emacs. Its goal is to
provide a nice set of features operating on a project level without
introducing external dependencies(when feasible). For instance -
finding project files has a portable implementation written in pure
Emacs Lisp without the use of GNU =find= (but for performance sake an
indexing mechanism backed by external commands exists as well). 

Projectile tries to be practical - portability is great, but if some
external tools could speed up some task substantially and the tools
are available, Projectile will leverage them. 

This library provides easy project management and navigation. The
concept of a project is pretty basic - just a folder containing
special file. Currently =git=, =mercurial=, =darcs= and =bazaar= repos are
considered projects by default. So are =lein=, =maven=, =sbt=, =rebar= and
bundler projects. If you want to mark a folder manually as a project
just create an empty .projectile file in it. Some of Projectile's
features:

- jump to a file in project
- jump to a directory in project
- jump to a file in a directory
- jump to a project buffer
- jump to a test in project
- toggle between code and its test
- jump to recently visited files in the project
- switch between projects you have worked on
- kill all project buffers
- replace in project
- multi-occur in project buffers
- grep in project
- regenerate project etags or gtags (requires gtags).
- visit project in dired
- run make in a project with a single key chord

Here's a glimpse of Projectile in action:

...[screenshot]...


*_Installation_*:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGES: projectile             ;;
  ;;                                  ;;
  ;; GROUP: Convenience -> Projectile ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (projectile-global-mode)
#+end_src
*_Usage_*: 

Please refer to the [[https://github.com/bbatsov/projectile#usage][usage]] on the homepage.

*** Package: =workgroups2=
:PROPERTIES:
:ID:       8860083f-a522-4249-847a-6d31317fce80
:END:

*_Author_*: 

[[http://pashinin.com/en/][Sergey Pashinin]], =sergey@pashinin.com=

Based on the original [[https://github.com/tlh/workgroups.el][workgroups]], created by tlh, =thunkout@gmail.com=.

*_Homepage_*: [[https://github.com/pashinin/workgroups2][Github]]

*_Features_*:

Workgroups is a session manager for Emacs.

- It saves all your opened buffers, their location and sizes on disk
  to restore later 

- You can create several workspaces

You can also restore such buffers as: org-agenda, shell, magit-status,
help.

*_Installation_*:
=M-x list-packages= and select *workgroups2* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: workgroups2               ;;
  ;;                                    ;;
  ;; GROUP: Convenience -> Workgroups   ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'workgroups2)
  ;; Change some settings
  (workgroups-mode 1)
#+end_src

*_Usage_*:

Most commands are bound to both <prefix> <key> and <prefix> C-<key>.

By default prefix is: "C-c z" (To change it - see settings below)

#+BEGIN_QUOTE
<prefix> <key>
<prefix> c    - create workgroup
<prefix> A    - rename workgroup
<prefix> k    - kill workgroup
<prefix> v    - switch to workgroup
<prefix> C-s  - save session
<prefix> C-f  - load session
<prefix> 0..9 - switch to workgroup at index 0..9
#+END_QUOTE

Do you remember [[http://tuhdo.github.io/emacs-tutor.html#sec-7-28][how to use registers to store window configurations]]?
Registers are good, but it does not allow you to name window
configurations. It would be trouble when the number of window
configurations getting large. You will have to tediously remember
which register stores which configuration.

With =workgroups2=, each window configuration is a workgroup, and you
can create as many workgroups and named it with =<prefix> c=; later,
you can switch back by =<prefix> v=. Because you can name your window
configurations, you don't have the burden to remember which to which
in registers. You can also save your window configurations to continue
using them in later Emacs sessions.
** Package on a league of its own: =helm=
:PROPERTIES:
:ID:       55f16efe-8346-419a-bbc6-899b8fbb76f5
:END:
*_Author_*:

- Tamas Patrovic (past maintainer), from 2007.
- rubikitch =rubikitch@ruby-lang.org=, from 2008-2011.
- [[https://github.com/thierryvolpiatto][Thierry Volpiatto]] (current
  maintainer). =thierry.volpiatto@gmail.com=, from 2011-present.

*_Homepage_*: [[https://github.com/emacs-helm/helm][Github]]

*_Features_*:
=Helm= is incremental completion and selection narrowing framework for
Emacs. It will help steer you in the right direction when you're
looking for stuff in Emacs (like buffers, files, etc).

Helm is a fork of =anything.el= originaly written by Tamas Patrovic and
can be considered to be its successor. =Helm= sets out to clean up the
legacy code in =anything.el= and provide a cleaner, leaner and more
modular tool, that's not tied in the trap of backward compatibility.

*_Installation_*:

=M-x list-packages= and select *helm* package, then
install it. After finish installing, add this code snippet to activate
the package:

Minimal config:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: helm              ;;
  ;;                            ;;
  ;; GROUP: Convenience -> Helm ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'helm-config)

#+end_src

My extended config:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: helm              ;;
  ;;                            ;;
  ;; GROUP: Convenience -> Helm ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'helm)
  (require 'helm-config)
  (require 'helm-eshell)
  (require 'helm-files)
  (require 'wgrep-helm)

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebihnd tab to do persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

  (eval-after-load 'helm-grep
    '(progn
       (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
       (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
       (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)))

  (setq
   helm-google-suggest-use-curl-p t
   helm-scroll-amount 4 ; scroll 4 lines other window using M-<next>/M-<prior>
   helm-quick-update t ; do not display invisible candidates
   helm-idle-delay 0.01 ; be idle for this many seconds, before updating in delayed sources.
   helm-input-idle-delay 0.01 ; be idle for this many seconds, before updating candidate buffer
   helm-ff-search-library-in-sexp t ; search for library in `require' and `declare-function' sexp.

   ;; you can customize helm-do-grep to execute ack-grep
   ;; helm-grep-default-command "ack-grep -Hn --smart-case --no-group --no-color %e %p %f"
   ;; helm-grep-default-recurse-command "ack-grep -H --smart-case --no-group --no-color %e %p %f"
   helm-split-window-default-side 'other ;; open helm buffer in another window
   helm-split-window-in-side-p t ;; open helm buffer inside current window, not occupy whole other window
   helm-buffers-favorite-modes (append helm-buffers-favorite-modes
                                       '(picture-mode artist-mode))
   helm-candidate-number-limit 200 ; limit the number of displayed canidates
   helm-M-x-requires-pattern 0     ; show all candidates when set to 0
   helm-boring-file-regexp-list
   '("\\.git$" "\\.hg$" "\\.svn$" "\\.CVS$" "\\._darcs$" "\\.la$" "\\.o$" "\\.i$") ; do not show these files in helm buffer
   helm-ff-file-name-history-use-recentf t
   helm-move-to-line-cycle-in-source t ; move to end or beginning of source
                                          ; when reaching top or bottom of source.
   ido-use-virtual-buffers t      ; Needed in helm-buffers-list
   helm-buffers-fuzzy-matching t          ; fuzzy matching buffer names when non--nil
                                          ; useful in helm-mini that lists buffers
   )

  (define-key helm-map (kbd "C-x 2") 'helm-select-2nd-action)
  (define-key helm-map (kbd "C-x 3") 'helm-select-3rd-action)
  (define-key helm-map (kbd "C-x 4") 'helm-select-4rd-action)

  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "C-c h m") 'helm-man-woman)
  (global-set-key (kbd "C-c h g") 'helm-do-grep)
  (global-set-key (kbd "C-c h f") 'helm-find)
  (global-set-key (kbd "C-c h l") 'helm-locate)
  (global-set-key (kbd "C-c h o") 'helm-occur)
  (global-set-key (kbd "C-h C-f") 'helm-apropos)

  ;; use helm to list eshell history
  (add-hook 'eshell-mode-hook
            #'(lambda ()
                (define-key eshell-mode-map (kbd "M-l")  'helm-eshell-history)))

  ;;; Save current position to mark ring
  (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)

  (helm-mode)
#+end_src

*_Usage_*:

After using Helm, you are going to have a big change in the way you
use Emacs. After getting used to the Helm way, you don't want to leave
it. However, if you don't like Helm, you can still use Ido, which is
introduted in later section. Let's learn how to use helm by play with
it.

Completion with Helm is very different with the usual Emacs
completion:

- You type someting.

- Instead of *TAB* to expand the common part until you find your
  candidates, in Helm, you type a parts of the candidate you want to
  search, separated by spaces. In Helm, these strings are called
  *patterns*.

- Helm will try to search and sort according to highest match, from
  top to bottom. The best match is at the top, so you can press *RET*
  and select it.

- You can navigate the buffer with *C-n* and *C-p* or *<up>* and
  *<down>* to move up/down, *C-v* and *M-v* to move to next/previous
  pages, and *M-<* and *M->* to move to top and bottom of the Helm
  buffer that is dispalying the candidates. Please try it.

When you execute a Helm command, you enter a Helm session. A Helm
session is a dedicated state to working with Helm features; while in a
Helm session, a dedicated Helm buffer is always opened. When you quit
a Helm session, a Helm buffer is closed. In Helm, you basically need
to remember the 3 commands:

- Access to action menu with *TAB*; an action menu is a text-based
  menu that lists actions you can take. For example, =Find File= (open
  file), =Find File in Dired=, =Grep File=...

- *C-z* executes *helm-execute-persistent-action*; a persistent action
  is an action that you use in a Helm session without quiting the
  session.

- In some Helm session, such as =helm-find-files= or =helm-mini=, you
  can select more than one candidates and execute actions on them,
  such as =grep= or =open=.

However, for convinience, let's *TAB* with *C-z* in the above
settings, so we can use *TAB* more comfortably, because you actually
use *helm-execute-persistent-action* more than
*helm-select-action* by adding the code snippet below:

#+begin_src emacs-lisp
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebihnd tab to do persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
#+end_src

In a Helm session, if you need help, use *C-c ?*, or refer to this
manual again. The commands in the key bindings above are good enough
to help you using Helm productively.

*** =helm-M-x=:
:PROPERTIES:
:ID:       500a1c68-ab43-40a5-97c3-5d556a9f748d
:END:

=M-x= and see the difference. You will see a buffer that lists
commands in Emacs. Some of you may not like it because it seems
overkill at first. However, even if you really don't like, please bear
with me until the end.

Now, type =li pa=; that's right =li= , a space and =pa=. You will see,
=list-packages= is at the top. Surprise! Let's try another input. Now,
type =pa ^li=, and you will receive =list-package= as the first
entry.

=helm-M-x= is also better then the default =M-x=, because it provides
key bindings right next to the commands, and *TAB* provides you the
built-in documentation of that command in another buffer.

*NOTE*: You have to bind =helm-M-x= to *M-x* manually. Otherwise, you
 still get Helm completion, but using the vanilla *M-x* that does not
 provides the above features like showing key bindings and *TAB* to
 open built-in documentation.
*** =helm-show-kill-ring=
:PROPERTIES:
:ID:       77b4d145-c280-4ed4-98a7-d645fe1d18bf
:END:
Do you remember that =C-y= [[http://tuhdo.github.io/emacs-tutor.html#sec-7-15][cycle the kill ring]]? However, working with
default kill ring is painful because you have a burden to remember an
invisible thing, that is the kill ring, at which position you kill
what. To view the kill ring, you have to *C-h v* and type =kill-ring=
to see content of the kill ring, and it is not pretty.

=helm-show-kill-ring= solves this problem: Helm shows the kill ring in
a readable format and allows you to narrow down by entering
sub-strings of candidates. You are lifted the cognitive burden when
using the default =M-y=.

If you follow my Helm configuration, =M-y= binds to
=helm-show-kill-ring=. Try it and see! Much easier than the default.

*** =helm-mini=
:PROPERTIES:
:ID:       0386c827-7f5d-4056-bf4d-8d0fc01fc1ab
:END:
This Helm command comprises of multiple sources:

- Current opening buffers, under the header =Buffers=.
- Recently opened files, under the header =Recentf=.
- Allow you to create a new buffer by pressing *RET*, under the header
  =Create Buffer=.

You can move back and forth between the groups by using *<left>* and
*<right>* arrow keys. Or you can just scroll down/up with *C-v* and
*M-v*.

You can filter out buffers by major mode using the query
=*<major-mode>=. For example, =*dired= narrows to only Dired
buffers. You can also filter out buffers that belong to a major mode
by adding =!= to the query. For example, =*!dired= select all buffers
that are not in Dired mode.

You can also select buffers in a specific directory by using the query
=/directory=. For example, =/.emacs.d/= narrows to buffers that are
only inside =.emacs.d=. Add =!= before the query for reverse
version. For example, =!/.emacs.d/= narrows to buffers not in
=.emacs.d=.

You can even use =helm-mini= to narrow to buffers that contains a
regexp in their contents, by using the query =@content=. For example,
you can select buffers that only contain the string "test":
=@test=. If you want to see the positions of the string in the
buffers, *C-s* while in =helm-mini= session to switch to
=helm-moccur=.

Example:

- If I enter in pattern prompt: "*lisp ^helm @moc"
  Helm will narrow down the list by selecting only buffers that are in
  lisp mode, start by helm and match \"moc\" in their contents.

- If I enter in pattern prompt: "*lisp ^helm moc"
  Notice there is no =@= this time helm will look for lisp mode
  buffers starting by "helm" and have "moc" in their name.

- If I enter in pattern prompt: "*!lisp !helm"
  Helm will narrow down to buffers that are not in \"lisp\" mode and
  that do not match "helm".

- If I enter in pattern prompt: "/helm/ w3"
  Helm will narrow down to buffers that are in any "helm" subdirectory
  and matching w3.

 =helm-mini= is like an interactive version of =ibuffer=.

*** =helm-find-files=
:PROPERTIES:
:ID:       b71abd6c-cb29-4b64-a55f-29bd75937c11
:END:
=helm-find-files= is file nagviation on steroid: 

- You can complete with partial basename. e.g "fob" or "fbr" will
  complete "foobar". With =helm-find-files=.

- You can also execute persistent action, which binds to *C-z* (by
  default), or *TAB* if you use my configuration to view content of
  the buffer. Move the buffer up/down by *M-<next>* and
  *M-<prior>*.

- You can go up one directory level with *C-l*. *_Important_*: if you
  use *C-l*, Helm goes up one level and the cursor is on the directory
  you've just got out. If you want to go up and have the cursosr on
  the parent directory, in Helm prompt, enter =../=.

- To create a directory, enter a new name that does not exist in the
  current directory and append =/= at the end. After you created a
  directory, Helm continues in that directory.

- To create a new file, enter a name and select the top row that has
  the symbol =[?]= next to it. By default, Helm always selects the
  first match in the directory.

- You can invoke =grep= on the current highlighting entry by
  *C-s*. *C-u C-s* to perform recursive grep.

- Enter =~/= at end of pattern to quickly reach home directory.

- Enter =/= at end of pattern to quickly reach root of your file system.

- Enter =./= at end of pattern to quickly reach `default-directory'
  (initial start of session). If you are in `default-directory' move
  cursor on top.

You can performa more actions on the highlighting entry by running
=helm-select-action=, which is bound to *TAB* by default and *C-z* in
my configuration.

*** =helm-man-woman=
:PROPERTIES:
:ID:       2578b1bd-7ae9-4250-b701-c9191603404f
:END:
With =helm-man-woman=, you can quickly jump to any man entry using
Helm interface. Give it a try.

*** =helm-do-grep=
:PROPERTIES:
:ID:       fb36142a-6b14-4f9f-a6c1-d58d2a004ddc
:END:
In the first part, you already saw my live grep demo:

[[file:static/live_grep.gif][file:static/live_grep.gif]]

*C-c h g* (if you use my key bindings) or =M-x helm-do-grep= to
perform live grep as you typing. Use prefix argument for recursive
grep. You can also invoke =helm-do-grep= in =helm-find-files= session
with *C-s*.

*** =helm-find=
:PROPERTIES:
:ID:       b7a95407-8629-48c4-bc9c-d0a391c95478
:END:
You can also quicly find a file with =helm-find=, binds to *C-c h f*
(in my configuratiohn). As usual, when you type a character, Helm
filters candidates accordingly.

*** =helm-locate=
:PROPERTIES:
:ID:       0e8e485d-c539-4175-9c81-9c8f9f17f608
:END:
Similar to =helm-find=, but you =locate= command.

*** =helm-occur=
:PROPERTIES:
:ID:       5fe9a6c3-5af2-4b4a-94ff-5849560c831f
:END:
Similar to =occur=, but using Helm interface. As you type, matching
lines are updated immediately. Very interactively, as it is the nature
of Helm.

*** =helm-apropos=
:PROPERTIES:
:ID:       479cdaab-0aba-48b8-b4d2-b026d23eb41a
:END:
Similar to *C-h a* which runs =apropos-command=, but use Helm
interface and update as you type.
** Alternative to Helm: =ido= + =flx-ido= + =smex=
:PROPERTIES:
:ID:       28093c3d-795a-484f-9801-95237f99fc20
:END:
*** Package: =flx-ido=
:PROPERTIES:
:ID:       c067eb7d-5aa0-47da-a603-431d38049d1a
:END:
*** Package: =smex=
:PROPERTIES:
:ID:       102d3ed8-a177-4a8f-a6e3-6da1195c2bcc
:END:
** setup-files.el
:PROPERTIES:
:ID:       1b1d3e93-3ebc-437a-b20d-f6d880d02ba1
:END:
My sample customization:

#+begin_src emacs-lisp
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Files                      ;;
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (setq large-file-warning-threshold 100000000) ;; size in bytes

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Files -> Back up            ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defvar backup-directory "~/.backups")
  (if (not (file-exists-p backup-directory))
      (make-directory backup-directory t))
  (setq
   make-backup-files t        ; backup a file the first time it is saved
   backup-directory-alist '((".*" . backup-directory)) ; save backup files in ~/.backups
   backup-by-copying t     ; copy the current file into backup directory
   version-control t   ; version numbers for backup files
   delete-old-versions t   ; delete unnecessary versions
   kept-old-versions 6     ; oldest versions to keep when a new numbered backup is made (default: 2)
   kept-new-versions 9 ; newest versions to keep when a new numbered backup is made (default: 2)
   auto-save-default t ; auto-save every buffer that visits a file
   auto-save-timeout 20 ; number of seconds idle time before auto-save (default: 30)
   auto-save-interval 200 ; number of keystrokes between auto-saves (default: 300)
   )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Files -> Dired              ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (setq
   dired-dwim-target t            ; if another Dired buffer is visibpple in another window, use that directory as target for Rename/Copy
   dired-recursive-copies 'always         ; "always" means no asking
   dired-recursive-deletes 'top           ; "top" means ask once for top level directory
   dired-listing-switches "-lha"          ; human-readable listing
   )

  ;; automatically refresh dired buffer on changes
  (add-hook 'dired-mode-hook 'auto-revert-mode)

  ;; if it is not Windows, use the following listing switches
  (when (not (eq system-type 'windows-nt))
    (setq dired-listing-switches "-lha --group-directories-first"))

  ;;; KEY BINDINGS.
  ;; (define-key ctl-x-map "\C-j" 'dired-jump)
  ;; (define-key ctl-x-4-map "\C-j" 'dired-jump-other-window))
  ;; (define-key dired-mode-map "\C-x\M-o" 'dired-omit-mode)
  ;; (define-key dired-mode-map "*O" 'dired-mark-omitted)
  ;; (define-key dired-mode-map "\M-(" 'dired-mark-sexp)
  ;; (define-key dired-mode-map "*(" 'dired-mark-sexp)
  ;; (define-key dired-mode-map "*." 'dired-mark-extension)
  ;; (define-key dired-mode-map "\M-!" 'dired-smart-shell-command)
  ;; (define-key dired-mode-map "\M-G" 'dired-goto-subdir)
  ;; (define-key dired-mode-map "F" 'dired-do-find-marked-files)
  ;; (define-key dired-mode-map "Y"  'dired-do-relsymlink)
  ;; (define-key dired-mode-map "%Y" 'dired-do-relsymlink-regexp)
  ;; (define-key dired-mode-map "V" 'dired-do-run-mail)
  (require 'dired-x) ; provide extra commands for Dired

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Files -> Dired -> Wdired    ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; wdired allows you to edit a Dired buffer and write changes to disk
  ;; - Switch to Wdired by C-x C-q
  ;; - Edit the Dired buffer, i.e. change filenames
  ;; - Commit by C-c C-c, abort by C-c C-k
  (require 'wdired)
  (setq
   wdired-allow-to-change-permissions t   ; allow to edit permission bits
   wdired-allow-to-redirect-links     ; allow to edit symlinks
   )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Files -> Recentf            ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (recentf-mode)
  (setq
   recentf-max-menu-items 30
   recentf-max-saved-items 5000
   )
#+end_src

*** Package: =dired+=
:PROPERTIES:
:ID:       fd414006-0a5c-4354-91fd-e68975aed67f
:END:
*_Author_*: [[http://www.emacswiki.org/emacs/DrewAdams][Drew Adams]], =drew.adams@oracle.com=

*_Homepage_*: [[http://www.emacswiki.org/emacs/DiredPlus][Emacswiki]]

*_Features_*:
=Dired+= (library =dired+.el=), which extends functionalities provided by
standard GNU Emacs libraries =dired.el=, =dired-aux.el=, and
=dired-x.el=. The standard functions are all available, plus many
more.

...[screenshot]....
...[screenshot]....
...[screenshot]....

*_Installation_*:
=M-x list-packages= and select *dired+* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: dired+                     ;;
  ;;                                     ;;
  ;; GROUP: Files -> Dired -> Dired Plus ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'dired+)
#+end_src

*_Usage_*:

Please refer to Emacswiki [[http://www.emacswiki.org/emacs/DiredPlus][usage]]. Note that =Dired+= has A LOT of
features, but you don't have to learn to use all of them at once. Even
the extra faces are useful enough.

*** Package: =recentf-ext=
:PROPERTIES:
:ID:       8013594a-f2f3-477c-820c-caf1354ac23d
:END:
*_Features_*:

Extension of `recentf' package.

- `dired' buffers can be handled.
- Switching to file buffer considers it as most recent file.

*_Installation_*:

=M-x list-packages= and select *recentf-ext* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: recentf-ext    ;;
  ;;                         ;;
  ;; GROUP: Files -> Recentf ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'recentf-ext)
#+end_src

*_Usage_*:

When you visit a directory, that directory is saved by =recentf= as well.

*** Package: =ztree=
:PROPERTIES:
:ID:       509e175b-8d72-472d-ad1c-7e96c647cb77
:END:
*_Author_*: [[https://github.com/fourier][Alexey Veretennikov]], =alexey.veretennikov@gmail.com=

*_Homepage_*: [[https://github.com/fourier/ztree][Github]]

*_Features_*:

Ztree is a project dedicated to implementation of several text-tree
applications inside Emacs. It consists of 2 subprojects: ztree-diff
and ztree-dir(the basis of ztree-diff).

- ztree-diff: Perform diff on two directories. Really handy when you
  want to create a big patch between two directories.

...[screenshot]...

- ztree-dir: a simple tree explorer.

...[screenshot]...

*_Installation_*:
=M-x list-packages= and select *ztree* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: ztree  ;;
  ;;                 ;;
  ;; GROUP: No group ;;
  ;;;;;;;;;;;;;;;;;;;;;
  ;; since ztree works with files and directories, let's consider it in
  ;; group Files
  (require 'ztree-diff)
  (require 'ztree-dir)
#+end_src

*_Usage_*:

=M-x ztree-diff=, then select the left and right directories to
compare.

=M-x ztree-dir= to explorer filesystem:

- Open/close directories with double-click, =RET= or =Space= keys.
- To jump to the parent directory, hit the =Backspace= key.
- To toggle open/closed state of the subtree of the current directory,
  hit the x key.

*** Package: =vlf=
:PROPERTIES:
:ID:       0bcdb090-e59b-4c02-96d1-47a1cc6173eb
:END:
*_Author_*: [[https://github.com/m00natic][Andrey Kotlarski]], =m00naticus@gmail.com=

*_Homepage_*: [[https://github.com/m00natic/vlfi][Github]]

*_Features_*:

Emacs minor mode that allows viewing, editing, searching and comparing
large files in batches. Batch size can be adjusted on the fly and
bounds the memory that is to be used for operations on the file. This
way multiple large files (like terabytes or whatever) can be instantly
and simultaneously accessed without swapping and degraded
performance.

This is development version of the GNU ELPA VLF package. Here’s what
it offers in a nutshell:

- regular expression search on whole file (in constant memory
  determined by current batch size)
- chunk editing (if size has changed, saving is done in constant
  memory determined by current batch size)
- Occur like indexing
- options to jump to beginning, end or arbitrary file chunk
- ability to jump/insert given number of batches at once
- newly added content is acknowledged if file has changed size
  meanwhile
- automatic scrolling of batches
- as a minor mode, font locking and functionality of the respective
  major mode is also present
- by batch Ediff comparison
- can be added as option to automatically open large files
- smooth integration with hexl-mode
- works with TRAMP so accessing network files is fine

GNU Emacs 23 and 24 are supported.

*_Installation_*:
=M-x list-packages= and select ** package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: vlf        ;;
  ;;                     ;;
  ;; GROUP: Files -> Vlf ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'vlf-integrate)
  (setq vlf-application 'dont-ask) ;; automatically use vlf on large file,
                                   ;; when the file exceed large-file-warning-threshold
#+end_src

*_Usage_*:

Please refer to [[https://github.com/m00natic/vlfi#detail-usage][Detail Usage]] section.

** setup-text.el
:PROPERTIES:
:ID:       73046aa4-06bc-47d6-8724-b291f429c154
:END:
I only use default configuration for "Text" group. You can customize
it if you want or leave this file blank, so you can add customizations
when needed. This group is useful if you edit text frequently and need
bibilography, or you want to write Latex.
** setup-data.el
:PROPERTIES:
:ID:       1147c642-b1c9-4faf-ad98-cd4611bf4b5a
:END:
Sample configuration:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Data -> Saveplace ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; saveplace remembers your location in a file when saving files
  (require 'saveplace)
#+end_src

** setup-external.el
:PROPERTIES:
:ID:       0131a13d-b070-48f8-910a-f63b35b93984
:END:
Sample configuration:

#+begin_src emacs-lisp
  ;,--------------------------------------
  ;| MAIN GROUP: Flyspell
  ;`--------------------------------------


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Processes -> Flyspell       ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (setq
   ispell-program-name "aspell"   ; use aspell instead of ispell
   ispell-extra-args '("--sug-mode=ultra") ; check as fast as
                      ; possible
   )
  (add-hook 'text-mode-hook 'flyspell-mode)
  (flyspell-prog-mode)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Processes -> Gud            ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (setq gud-chdir-before-run nil
  (gud-tooltip-mode)
#+end_src
** setup-communication.el
:PROPERTIES:
:ID:       d8f077a9-f7cb-4fdb-b587-461a2327fd1d
:END:
This group allows to customize communications, networking, and remote
access to files. For example, ftp, ldap, dig, whois, netstat... I am
find with the defaults. Customize more if you want and add to this
file.
** setup-programming.el
:PROPERTIES:
:ID:       c8702833-48cf-4cf8-b2e6-0f4ef7f4c8ab
:END:
Sample configuration:

#+begin_src emacs-lisp
  ;,--------------------------------------
  ;| MAIN GROUP: Programming
  ;`--------------------------------------

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Programming -> Languages -> C  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; Available C style:
  ;; “gnu”: The default style for GNU projects
  ;; “k&r”: What Kernighan and Ritchie, the authors of C used in their book
  ;; “bsd”: What BSD developers use, aka “Allman style” after Eric Allman.
  ;; “whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
  ;; “stroustrup”: What Stroustrup, the author of C++ used in his book
  ;; “ellemtel”: Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,” Erik Nyquist and Mats Henricson, Ellemtel
  ;; “linux”: What the Linux developers use for kernel development
  ;; “python”: What Python developers use for extension modules
  ;; “java”: The default style for java-mode (see below)
  ;; “user”: When you want to define your own style
  (setq
   c-default-style "linux" ;; set style to "linux"
   c-basic-offset 4
   )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Programming -> Tools -> Gdb ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (setq
   gdb-many-windows t             ; use gdb-many-windows by default
   gdb-show-main t            ;Non-nil means display source
                      ;file containing the main
                      ;routine at startup
   )


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Programming -> Tools -> Compilation ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Compilation from Emacs

  (defun prelude-colorize-compilation-buffer ()
    "Colorize a compilation mode buffer."
    (interactive)
    ;; we don't want to mess with child modes such as grep-mode, ack, ag, etc
    (when (eq major-mode 'compilation-mode)
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  (require 'compile)
  (setq compilation-ask-about-save nil ; Just save before compiling
        compilation-always-kill t ; Just kill old compile processes before
                                          ; starting the new one
        compilation-scroll-output 'first-error ; Automatically scroll to first
                                          ; error
        )
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Programming -> Tools -> Makefile ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; takenn from prelude-c.el:48: https://github.com/bbatsov/prelude/blob/master/modules/prelude-c.el
  (defun prelude-makefile-mode-defaults ()
    (whitespace-toggle-options '(tabs))
    (setq indent-tabs-mode t ))

  (setq prelude-makefile-mode-hook 'prelude-makefile-mode-defaults)

  (add-hook 'makefile-mode-hook (lambda ()
                                  (run-hooks 'prelude-makefile-mode-hook)))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Programming -> Tools -> Ediff ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (setq
   ediff-diff-options "-w"
   ediff-split-window-function 'split-window-horizontally
   ediff-window-setup-function 'ediff-setup-windows-plain
   )
#+end_src

*** Package: =diff-hl=
:PROPERTIES:
:ID:       277b9a96-a515-42e5-82f9-559fe3a6c3db
:END:
*_Author_*: [[https://github.com/dgutov][Dmitry Gutov]], =dgutov@yandex.ru=

*_Homepage_*: [[https://github.com/dgutov/diff-hl][Github]]

*_Features_*: 

=diff-hl-mode= highlights uncommitted changes on the left side of the
window, allows you to jump between and revert them selectively.

For the usage instructions and the list of commands, see the Commentary section inside the file.

Tested with Git, Mercurial, Bazaar and SVN. May work with other VC backends, too.

The package also contains auxiliary modes:

- =diff-hl-dired-mode= provides similar functionality in Dired.
- =diff-hl-margin-mode= changes the highlighting function to use the margin instead of the fringe.
- =diff-hl-amend-mode= shifts the reference revision back by one.

...[screeshot]...

*_Installation_*:
=M-x list-packages= and select *diff-hl* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: diff-hl                             ;;
  ;;                                              ;;
  ;; GROUP: Programming -> Tools -> Vc -> Diff Hl ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (global-diff-hl-mode)
  (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
#+end_src

*_Usage_*: 

*** Package: =magit=
:PROPERTIES:
:ID:       16744867-3d54-4212-856f-7742f2354706
:END:
*_Author_*: 

Original Author: Marius Vollmer =marius.vollmer@gmail.com=

Maintainer: [[https://github.com/tarsius][Jonas Bernoulli]], =jonas@bernoul.li=

Former-Maintainers:
- Nicolas Dudebout, =nicolas.dudebout@gatech.edu=
- Peter J. Weisberg, =pj@irregularexpressions.net=
- Phil Jackson, =phil@shellarchive.co.uk=
- Rémi Vanicat, =vanicat@debian.org=
- Yann Hodique, =yann.hodique@gmail.com=

*_Homepage_*: [[http://magit.github.io]]

*_Features_*:
Magit is an interface to the version control system Git, implemented
as an Emacs extension.

Unlike Emacs' native Version Control package which strives to provide
a unified interface to various version control systems, Magit only
supports Git and can therefore better take advantage of its native
features.

Magit supports GNU Emacs 23.2 or later; 24.1 or later is
recommended. Magit supports Git 1.7.2.5 or later; 1.8.2 or later is
recommended. The minimal versions are those available in Debian
oldstable.

*_Installation_*:
=M-x list-packages= and select ** package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: magit                       ;;
  ;;                                      ;;
  ;; GROUP: Programming -> Tools -> Magit ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'magit)
  (set-default 'magit-stage-all-confirm nil)
  (add-hook 'magit-mode-hook 'magit-load-config-extensions)

  ;; full screen magit-status
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))

  (global-unset-key (kbd "C-x g"))
  (global-set-key (kbd "C-x g h") 'magit-log)
  (global-set-key (kbd "C-x g f") 'magit-file-log)
  (global-set-key (kbd "C-x g b") 'magit-blame-mode)
  (global-set-key (kbd "C-x g m") 'magit-branch-manager)
  (global-set-key (kbd "C-x g c") 'magit-branch)
  (global-set-key (kbd "C-x g s") 'magit-status)
  (global-set-key (kbd "C-x g g") 'helm-git-grep)
  (global-set-key (kbd "C-x g l") 'helm-ls-git-ls)
  (global-set-key (kbd "C-x g r") 'magit-reflog)
  (global-set-key (kbd "C-x g t") 'magit-tag)
#+end_src

*_Usage_*:

Getting started with Magit is really easy:

- =M-x magit-status= to see git status, and in the status buffer:
- =s= to stage files
- =c c= to commit, type in your commit message then =C-c C-c= to save
  the message and commit, =C-c C-k= to abort current commit message
  and go back magit-status.
- =b b= to switch to a branch.

Other handy keys:

- =P P= to do a git push
- =F F= to do a git pull
- try to press TAB on entries.

If you want to view the raw git commands, i.e. you want to know how
=git push= is doing, press *$*.

For more usage, please refer to the [[http://magit.github.io/documentation][official manual.]]

*** Package: =flycheck=
:PROPERTIES:
:ID:       23dedddc-be7f-41cd-b17b-5670d1fcf0d2
:END:
*_Author_*: [[https://github.com/lunaryorn][Sebastian Wiesner]], =swiesner@lunaryorn.com=

*_Homepage_*: [[http://flycheck.readthedocs.org/en/latest/][http://flycheck.readthedocs.org/]]

*_Features_*:

- Supports over 30 programming and markup languages with more than 60 different syntax checking tools
- Fully automatic, fail-safe, on-the-fly syntax checking in background
- Nice error indication and highlighting
- Optional error list popup
- Many customization options
- A comprehensive manual
- A simple interface to define new syntax checkers
- A “doesn't get in your way” guarantee
- Many [[http://flycheck.readthedocs.org/en/latest/guide/introduction.html#rd-party-extensions][3rd party extensions]]

*_Installation_*;

=M-x list-packages= and select *flycheck* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: flycheck                       ;;
  ;;                                         ;;
  ;; GROUP: Programming -> Tools -> Flycheck ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'flycheck)
  (add-hook 'after-init-hook #'global-flycheck-mode)
#+end_src

*_Usage_*: 

After you installed and activated flycheck, your supported buffers
are automatically checked against errors as you typed and the errors
are displayed in echo area.

*** Package: =flycheck-tip=
:PROPERTIES:
:ID:       1e5070dd-c73a-4fe8-a8da-298ad1e74054
:END:
*_Author_*: [[https://github.com/yuutayamada][Yuta Yamada]], =cokesboy@gmail.com=

*_Homepage_*: [[https://github.com/yuutayamada/flycheck-tip][Github]]

*_Features_*:

Show flycheck error by popupo.

*_Installation_*:
=M-x list-packages= and select *flycheck-tip* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: flycheck-tip                                      ;;
  ;;                                                            ;;
  ;; GROUP: Flycheck Tip, but just consider it part of Flycheck ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'flycheck-tip)
  (flycheck-tip-use-timer 'verbose)
#+end_src

*_Usage_*:

The errors are now displayed by popup, instead of printing into the
echo area. Echo area should be preserved for other things like
=eldoc-mode=.

** setup-applications.el
:PROPERTIES:
:ID:       eba1989e-6113-4ac4-ba44-17094418f080
:END:
Sample configuration:

#+begin_src emacs-lisp
  ;,--------------------------------------
  ;| MAIN GROUP: Applications
  ;`--------------------------------------

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Applications-> Eshell       ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'eshell)
  (require 'em-alias)

  (eshell/alias "o" "")
  (eshell/alias "o" "find-file-other-window $*")
  (eshell/alias "vi" "find-file-other-window $*")
  (eshell/alias "vim" "find-file-other-window $*")
  (eshell/alias "emacs" "find-file-other-window $*")
  (eshell/alias "em" "find-file-other-window $*")

  (eshell-toggle-direct-send)

  ;; change listing switches based on OS
  (when (not (eq system-type 'windows-nt))
    (eshell/alias "ls" "ls --color -h --group-directories-first $*"))

  (add-hook 'eshell-mode-hook 'electric-pair-mode)
#+end_src

I only use Eshell. You should modify others if you need.

** setup-development.el
:PROPERTIES:
:ID:       7b8b3b61-ae0e-4ae4-b998-165a78a8512d
:END:
Sammple configuration:

#+begin_src emacs-lisp
  ;,--------------------------------------
  ;| MAIN GROUP: Development
  ;`--------------------------------------

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Development -> Extensions -> Eldoc  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Development -> Extensions -> Ido ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Uncomment if you want to use Ido
  ;; I am going to introduce a tool, argurably better, that
  ;; replaces Ido: Helm

  ;; (require 'ido)

  ;; (setq
  ;;  ido-enable-dot-prefix t
  ;;  ido-enable-flex-matching t
  ;;  ido-create-new-buffer 'always
  ;;  ido-use-filename-at-point 'guess
  ;;  ido-max-prospects 10
  ;;  ido-default-file-method 'selected-window
  ;;  )
  ;; (ido-mode)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Development -> Internal     ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Start garbage collection every 100MB
  (setq gc-cons-threshold 100000000)
#+end_src

** setup-environment.el
:PROPERTIES:
:ID:       052d0e7c-f8c3-4288-9eb1-57cee9c63dab
:END:
Sample configuration:

#+begin_src emacs-lisp
  ;,--------------------------------------
  ;| MAIN GROUP: Environment
  ;`--------------------------------------

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Environment -> Initialization ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (setq
   inhibit-startup-screen t
   )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Environment -> Minibuffer   ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (icomplete-mode)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Environment -> Minibuffer -> Savehist ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; savehist saves minibuffer history by defaults
  (setq
   savehist-additional-variables '(search ring regexp-search-ring) ;; also save your regexp search queries
   savehist-autosave-interval 60 ;; save every minute
   )
  (savehist-mode) ;; enable savehist

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Environment -> Mode Line    ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (column-number-mode)
#+end_src

*** Package: =nyan-mode=
:PROPERTIES:
:ID:       e105a01f-2fbb-4ccb-b9a9-cc08fcbc6097
:END:

*_Author_*: Jacek "TeMPOraL" Zlydach, =temporal.pl@gmail.com=

*_Homepage_*: [[http://nyan-mode.buildsomethingamazing.com/]]

*_Features_*:

Nyan Mode is an analog indicator of your position in the buffer. The
Cat should go from left to right in your mode-line, as you move your
point from 0% to 100%.

[[file:static/part3/nyan-mode.png][file:static/part3/nyan-mode.png]]


- Mind dumbing content included,
- Experimental animation (M-x nyan-start-animation, M-x
  nyan-stop-animation),
- Wavy rainbow (M-x set-variable <ret> nyan-wavy-trail <ret> t),
- Customizable properties.

NOT INCLUDED: music.

*_Installation_*:
=M-x list-packages= and select *nyan-mode* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: nyan-mode                    ;;
  ;;                                       ;;
  ;; GROUOP: Environment -> Frames -> Nyan ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; only turn on if a window system is available
  ;; this prevents error under terminal that does not support X
  (case window-system
    ((x w32) (nyan-mode)))
#+end_src

*_Usage_*:

As you scroll through a buffer, the cat moves to indicate the position
in buffer.

** setup-faces-and-ui.el
:PROPERTIES:
:ID:       ee26ceb9-d308-4ea5-a96c-a805b33079a0
:END:
Sample configuration:

#+begin_src emacs-lisp
  ;; you won't need any of the bar thingies
  ;; turn it off to save screen estate
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))

  ;; the blinking cursor is nothing, but an annoyance
  (blink-cursor-mode -1)

  (setq scroll-margin 0
        scroll-conservatively 100000
        scroll-preserve-screen-position 1)

  (size-indication-mode t)

  ;; more useful frame title, that show either a file or a
  ;; buffer name (if the buffer isn't visiting a file)
  ;; taken from prelude-ui.el
  (setq frame-title-format
        '("" invocation-name " - " (:eval (if (buffer-file-name)
                                                      (abbreviate-file-name (buffer-file-name))
                                                    "%b"))))
#+end_src

*** Package: =number-font-lock=
:PROPERTIES:
:ID:       26a9a3fb-b564-4827-81f1-c82c2809c73e
:END:
*_Author_*: [[https://github.com/Fanael][Fanael Linithien]], =fanael4@gmail.com=

*_Homepage_*: [[https://github.com/Fanael/number-font-lock-mode][Github]]

*_Features_*:

=number-font-lock-mode= is an Emacs minor mode that highlights numeric
literals in source code.

*_Installation_*:

=M-x list-packages= and select *number-font-lock* package, then
install it. After finish installing, add this code snippet to activate
the package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: number-font-lock          ;;
  ;;                                    ;;
  ;; GROUP: Faces -> Number Font Lock   ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (add-hook 'prog-mode-hook 'number-font-lock-mode)
#+end_src

*_Usage_*: 

Numbers automatically have distinct colors in buffer.

*** Package: =highlight-symbol=
:PROPERTIES:
:ID:       726fdb67-5494-4761-a1b6-379cabc73c85
:END:
*_Author_*: [[https://github.com/nschum][Nikolaj Schumacher]], =me@nschum.de=

*_Homepage_*: [[https://github.com/nschum/highlight-symbol.el][Github]]

*_Features_*:

Automatic and manual symbol highlighting for Emacs.

*_Installation_*:

=M-x list-packages= and select *highlight-symbol* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  (require 'highlight-symbol)

  (highlight-symbol-nav-mode)

  (add-hook 'prog-mode-hook (lambda () (highlight-symbol-mode)))
  (add-hook 'org-mode-hook (lambda () (highlight-symbol-mode)))
  (setq highlight-symbol-on-navigation-p t) ; enable highlighting symbol at point automatically

  (global-set-key [(control shift mouse-1)]
                  (lambda (event)
                    (interactive "e")
                    (goto-char (posn-point (event-start event)))
                    (highlight-symbol-at-point)))

  (global-set-key (kbd "M-n") 'highlight-symbol-next)
  (global-set-key (kbd "M-p") 'highlight-symbol-prev)
#+end_src

*_Usage_*:

If you move point on a symbol, it automatically highlights all the
symbols in the current screen. From now on, pressing *M-n* and *M-p*
will immeidately jump to the next/previous symbols in a buffer.

** setup-help.el
:PROPERTIES:
:ID:       0b7ba2b9-8cce-4516-b7ad-ff351b30994b
:END:
*** Package: =info+=
:PROPERTIES:
:ID:       d9f960bc-0ef7-49df-b7d8-4c98f99893ac
:END:
*_Author_*: [[http://www.emacswiki.org/emacs/DrewAdams][Drew Adams]], =drew.adams@oracle.com=

*_Homepage_*: [[http://www.emacswiki.org/emacs/InfoPlus][Emacswiki]]

*_Features_*:
Info+ helps you read Info documents more enjoyable with extra
highlighting it provides.

*_Installation_*:

=M-x list-packages= and select *info+* package, then
install it. After finish installing, add this code snippet to activate
the package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Help -> Info+               ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'info+)
#+end_src

*** Package: =discover-my-major=
:PROPERTIES:
:ID:       f1eadf8c-e8d5-49f0-9c8a-2b14b5129da5
:END:
*_Author_*: [[http://steckerhalter.co.vu/][steckerhalter]]

*_Homepage_*: [[https://github.com/steckerhalter/discover-my-major][Github]]

*_Features_*:

Discover key bindings and their meaning for the current Emacs major mode.

[[file:static/part3/discover-my-major.png][file:static/part3/discover-my-major.png]]

*_Installation_*:
=M-x list-packages= and select *discover-my-major* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;; A quick major mode help with discover-my-major
  (define-key 'help-command (kbd "C-m") 'discover-my-major)
#+end_src

*_Usage_*:

*** Package: =rainbow-mode=
:PROPERTIES:
:ID:       c0171162-e9cf-4e6e-a96b-b8304f68b020
:END:
*_Author_*: Julien Danjou, =julien@danjou.info=

*_Homepage_*: [[http://elpa.gnu.org/packages/rainbow-mode.html][GNU ELPA]]

*_Features_*:

This minor mode sets background color to strings that match color
names, e.g. #0000ff is displayed in white with a blue background.

[[file:static/part3/rainbow-mode.png][file:static/part3/rainbow-mode.png]]

*_Installation_*:
=M-x list-packages= and select *rainbow-mode* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: rainbow-mode              ;;
  ;;                                    ;;
  ;; GROUP: Help -> Rainbow             ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (add-hook 'html-mode-hook 'rainbow-mode)
  (add-hook 'css-mode-hook 'rainbow-mode)
#+end_src

It is useful to always activate =rainbow-mode= in those two major
modes. For other modes, it is situational, so I don't use
=prog-mode-hook=.

*_Usage_*:

As you type a hex number or a color string in a buffer with
=rainbow-mode= activated, the hex number or color string is
colourized.
*** Package: =help+=
:PROPERTIES:
:ID:       eb0f4552-02af-4500-a839-82016cff719c
:END:
*_Author_*: [[http://www.emacswiki.org/emacs/DrewAdams][Drew Adams]], =drew.adams@oracle.com=

*_Homepage_*: [[http://www.emacswiki.org/emacs/HelpPlus][Emacswiki]]

*_Features_*:

Extensions to `help.el' for Emacs 

*_Installation_*:

=M-x list-packages= and select *help+* package, then
install it. After finish installing, add this code snippet to activate
the package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Package: help+                     ;;
  ;;                                    ;;
  ;; GROUP: Help                        ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'help+)
#+end_src

*_Usage_*:

The following bindings are made:

  `C-h u'      `manual-entry'
  `C-h C-a'    `apropos'
  `C-h C-l'    `locate-library'
  `C-h RET'    `help-on-click/key'
  `C-h M-a'    `apropos-documentation'
  `C-h M-o'    `pop-to-help-toggle'
  `C-h C-M-a'  `tags-apropos'
  [mouse-1]    `mouse-help-on-click' (non-mode-line)
  [mouse-1]    `mouse-help-on-mode-line-click' (mode-line)

*** Package: =help-fns+=
:PROPERTIES:
:ID:       8fd8c1ee-555c-4ba4-9513-176c5e382b72
:END:
*_Author_*: [[http://www.emacswiki.org/emacs/DrewAdams][Drew Adams]], =drew.adams@oracle.com=

*_Homepage_*: [[http://www.emacswiki.org/emacs/HelpPlus][Emacswiki]]

*_Features_*:

Extensions to `help-fns.el'

*_Installation_*:

=M-x list-packages= and select *help-fns+* package, then
install it. After finish installing, add this code snippet to activate
the package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Package: help-fns+                 ;;
  ;;                                    ;;
  ;; GROUP: Help                        ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'help-fns+)
#+end_src

*_Usage_*:

Keys bound here:

  `C-h B'      `describe-buffer'
  `C-h c'      `describe-command'     (replaces `describe-key-briefly')
  `C-h o'      `describe-option'
  `C-h C-c'    `describe-key-briefly' (replaces `C-h c')
  `C-h C-o'    `describe-option-of-type'
  `C-h M-c'    `describe-copying'     (replaces `C-h C-c')
  `C-h M-f'    `describe-file'
  `C-h M-k'    `describe-keymap'
  `C-h M-l'    `find-function-on-key'

*** Package: =help-mode+=
:PROPERTIES:
:ID:       6d65f9ca-ab61-4d8e-83ac-40f9325e1780
:END:
*_Author_*: [[http://www.emacswiki.org/emacs/DrewAdams][Drew Adams]], =drew.adams@oracle.com=

*_Homepage_*: [[http://www.emacswiki.org/emacs/HelpModePlus][Emacswiki]]

*_Features_*:

Extensions to `help-mode.el'

Links to libraries are provided whenever library names appear in
buffer ‘*Help*’. After loading help-mode+.el, library names in buffer
*Help* have mouse-over links to the corresponding library code. 

For example, ‘C-h v features’ describes the variable ‘features’; this
description lists all of the libraries currently loaded in Emacs.

- In vanilla Emacs (without help-mode+.el loaded), the library names
  are not linked, unless a library (such as ‘grep’) happens to have
  the same name as an Emacs function or variable, in which case
  clicking the name displays the function or variable description in
  buffer *Help*.

- With help-mode+.el loaded, each library name in the ‘C-h v features’
  list is linked to the library (code) itself. Click a name to
  edit/view the library file.

*_Installation_*:

=M-x list-packages= and select *help-mode+* package, then
install it. After finish installing, add this code snippet to activate
the package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Package: help-mode+                ;;
  ;;                                    ;;
  ;; GROUP: Help                        ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'help-mode+)
#+end_src

*_Usage_*:

If a =*Help*= buffer contains other library names, the names
automatically becomes links to jump to.

** setup-local.el
:PROPERTIES:
:ID:       3a088d14-a8ae-4c4d-8526-57e60307f1d8
:END:
If you define your own Customization Group locally to your
computer, your Customization Group should be added under =Local=
parent and customize it here. The only sub-group in =Local= group is
=holidy=, and I do not use it, so I leave this file blank.
** setup-ido.el
:PROPERTIES:
:ID:       de428bfd-de8d-4b53-ae08-1b7fd53ff1cb
:END:
** setup-windows.el
:PROPERTIES:
:ID:       738556d6-e56f-464b-87f6-e1d7878f7d5e
:END:
*** Built-in: winner-mode
:PROPERTIES:
:ID:       d90e7bb7-2470-4bae-a184-9c41009098a1
:END:
*** Package: golden-ratio
:PROPERTIES:
:ID:       f6ac2425-ef91-493e-bdb0-a50cc0ade267
:END:
* More Emacs Lisp resources
:PROPERTIES:
:ID:       18ccd3a6-7545-4c7a-9b2b-3106dd05bdde
:END:
