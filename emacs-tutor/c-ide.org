#+TITLE: C/C++ Development Environment for Emacs

In this guide, I will help you to setup an efficient working C/C++
environment. Despite it looks long, the setup is short and easy
(mostly copy/paste Emacs Lisp code into your =init.el=); most of the
guide are explanations and demonstrations of many useful features.

Please remember that there's a table of content on the top right
corner and you can use it to navigate this guide. If you feel your
internet connection is too slow for my guide, you can always clone and
read it offline: https://github.com/tuhdo/tuhdo.github.io

*Update 22 Aug 2014*: I added an Emacs repository that is properly
configured for demonstration purpose. You can clone and play with it
and you can ignore all the Elisp code for setting up throughout the
guide:

#+begin_src shell-script
  git clone https://github.com/tuhdo/emacs-c-ide-demo.git ~/.emacs.d
#+end_src

Remember to backup your =~/.emacs.d= elsewhere. In the demo
repository, I already installed both =ggtags= and
=helm-gtags=. =helm-gtags= is enabled by default. If you want to use
=ggtags=, comment this line in =init.el=:

#+begin_src emacs-lisp
  (require 'setup-helm-gtags)
#+end_src

And uncomment this line:

#+begin_src emacs-lisp
  ;; (require 'setup-ggtags)
#+end_src

* Source code navigation
:PROPERTIES:
:ID:       2b850804-a33b-4f37-96fd-5bb4e422dbee
:END:
** Prerequisite:
:PROPERTIES:
:ID:       b1292347-d0ed-4421-9905-33f1050883b2
:END:
- Know how to use =package.el= and MELPA. If you don't know how to
  use, read the guide [[file:emacs-tutor3.org::*How%20to%20use%20Emacs%20package%20manager][How to use Emacs package manager]].

- Install [[https://github.com/leoliu/ggtags][ggtags]]. After installing =ggtags= from MELPA, add this code
  snippet to setup =ggtags= and key bindings:

#+begin_src emacs-lisp
  (require 'ggtags)
  (add-hook 'c-mode-common-hook
            (lambda ()
              (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
                (ggtags-mode 1))))

  (define-key ggtags-mode-map (kbd "C-c g s") 'ggtags-find-other-symbol)
  (define-key ggtags-mode-map (kbd "C-c g h") 'ggtags-view-tag-history)
  (define-key ggtags-mode-map (kbd "C-c g r") 'ggtags-find-reference)
  (define-key ggtags-mode-map (kbd "C-c g f") 'ggtags-find-file)
  (define-key ggtags-mode-map (kbd "C-c g c") 'ggtags-create-tags)
  (define-key ggtags-mode-map (kbd "C-c g u") 'ggtags-update-tags)

  (define-key ggtags-mode-map (kbd "M-,") 'pop-tag-mark)
#+end_src

- Or, [[https://github.com/emacs-helm/helm][helm]] + [[https://github.com/syohex/emacs-helm-gtags][helm-gtags]]. Helm is awesome and if you are going to use
  Helm, please read the [[http://tuhdo.github.io/helm-intro.html][Helm guide]].

#+begin_src emacs-lisp
  ;; this variables must be set before load helm-gtags
  ;; you can change to any prefix key of your choice
  (setq helm-gtags-prefix-key "\C-cg")

  (require 'helm-gtags)

  (setq
   helm-gtags-ignore-case t
   helm-gtags-auto-update t
   helm-gtags-use-input-at-cursor t
   helm-gtags-pulse-at-cursor t

   helm-gtags-suggested-key-mapping t
   )

  ;; Enable helm-gtags-mode in Dired so you can jump to any tag
  ;; when navigate project tree with Dired
  (add-hook 'dired-mode-hook 'helm-gtags-mode)

  ;; Enable helm-gtags-mode in Eshell for the same reason as above
  (add-hook 'eshell-mode-hook 'helm-gtags-mode)

  ;; Enable helm-gtags-mode in languages that GNU Global supports
  (add-hook 'c-mode-hook 'helm-gtags-mode)
  (add-hook 'c++-mode-hook 'helm-gtags-mode)
  (add-hook 'java-mode-hook 'helm-gtags-mode)
  (add-hook 'asm-mode-hook 'helm-gtags-mode)

  ;; key bindings
  (define-key helm-gtags-mode-map (kbd "M-s") 'helm-gtags-select)
  (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
  (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
  (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
  (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
#+end_src

** Basic movements
:PROPERTIES:
:ID:       45f1bb42-08e5-43b9-8ea9-7b5e1124f89e
:END:
- *C-M-f* runs =forward-sexp=, move forward over a balanced
  expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/forward-func.gif][file:static/c-ide/forward-func.gif]]

- *C-M-b* runs =backward-sexp=, move backward over a balanced
  expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/backward-func.gif][file:static/c-ide/backward-func.gif]]

- *C-M-k* runs =kill-sexp=, kill balanced expression
  forward that can be a pair or a symbol. Demo:

  [[file:static/c-ide/kill-func-body.gif][file:static/c-ide/kill-func-body.gif]]

- *C-M-<SPC>* or *C-M-@* rusn =mark-sexp=, put mark after
  following expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/mark-func-body.gif][file:static/c-ide/mark-func-body.gif]]

- *C-M-a* runs =beginning-of-defun=, which moves point to beginning of
  a function. Demo:

  [[file:static/c-ide/beginning-of-defun.gif][file:static/c-ide/beginning-of-defun.gif]]

- *C-M-e* runs =end-of-defun=, which moves point to end of a
  function. Demo:

  [[file:static/c-ide/end-of-defun.gif][file:static/c-ide/end-of-defun.gif]]

- *C-M-h* runs =mark-defun=, which put a region around whole current
  or following function. Demo:

  [[file:static/c-ide/mark-defun.gif][file:static/c-ide/mark-defun.gif]]

** Find definitions in current buffer
:PROPERTIES:
:ID:       3a64c7a4-e8a5-42b9-9476-28dff9e5cb96
:END:
The Imenu facility offers a way to find the major definitions, such as
function definitions, variable definitions in a file by name. =ggtags=
can integrate Imenu:

#+begin_src emacs-lisp
  (setq-local imenu-create-index-function #'ggtags-build-imenu-index)
#+end_src

If you use Helm, use [[http://tuhdo.github.io/helm-intro.html#sec-7][helm-semantic-or-imenu]].

** Find definitions in project
:PROPERTIES:
:ID:       0331265b-7c3f-457e-ba1d-ef6c3cd24208
:END:
- Using =gtags=: by default, =M-.= runs =ggtags-find-tag-dwim= when
  =ggtags-mode= is enabled. The command =ggtags-find-tag-dwim= jump to
  tag base on context:

  - If the tag at point is a definition, =ggtags= jumps to a
    reference. If there is more than one reference, it displays a list
    of references.

  - If the tag at point is a reference, =ggtags= jumps to tag
    definition.

  - If the tag at point is an include header, it jumps to that header.

You can jump back to original location where you invoked
=ggtags-find-tag-dwim= by =M-,=, which runs =pop-tag-mark= (if you
follow my key bindings).

You can also find arbitrary tag definition when invoking =M-.= on
blank space. A prompt asks you for tag pattern, which is a regexp.

If =ggtags= gives you a list of candidates, you can use =M-n= to move
to next candidate and =M-p= to move back previous candidate. Use =M-g
s= to invoke Isearch on candidate buffer list.

#+BEGIN_CENTER
[[file:static/c-ide/ggtags-definitions.png][file:static/c-ide/ggtags-definitions.png]]

(screenshot taken from [[https://github.com/leoliu/ggtags][ggtags]])
#+END_CENTER

- Using =helm-gtags=: If key bindings are properly setup as above,
  =M-.= runs =helm-gtags-dwim=, which behaves the same as
  =ggtags-find-tag-dwim=. Similarly, you jump back to original
  location by using =M-,=, which runs =tags-loop-continue= (Emacs
  default).

#+BEGIN_CENTER
[[file:static/c-ide/helm-gtags-definitions.png][file:static/c-ide/helm-gtags-definitions.png]]

(screenshot taken from [[https://github.com/syohex/emacs-helm-gtags][helm-gtags]])
#+END_CENTER

You can also find arbitrary tag definition when invoking =M-.= on
blank space. A prompt asks you for tag pattern, which is a
regexp. =helm-gtags= provides a really nice feature that uses Helm to
display all tags in a project and incrementally filtering, and is
really fast:

[[file:static/c-ide/helm-gtags-select.gif][file:static/c-ide/helm-gtags-select.gif]]

** Find references in project
:PROPERTIES:
:ID:       410cfad4-a08d-4139-8c37-cb1bff5bd44e
:END:
- Using =ggtags=:  Either run =ggtags-find-tag-dwim= or
  =ggtags-find-reference=, which only finds references.

- Using =helm-gtags=: Either run =helm-gtags-dwim= or
  =helm-gtags-find-rtag=, which only finds references.

** Find files in project
:PROPERTIES:
:ID:       b6c7d5a9-2fce-4488-a7d5-3eb301b6b89a
:END:
- Using =ggtags=: Run =ggtags-find-file= to find a file from all the
  files indexed.

- Using =helm-gtags=: Run =helm-gtags-find-files= to find files
  matching regexp.

** View visited tags with tag stack
:PROPERTIES:
:ID:       db6bf87e-969d-42b8-ae60-b0b58f13e073
:END:
- Using =ggtags=: As you know that you can jump back with
  =pop-tag-mark= (bound to =M-,=), you can also view a list of visited
  tags using =ggtags-view-tag-history=, which is bound to =C-c g
  h=. It displays visited tags from newest to oldest, that is from top
  to bottom.

- Using =helm-gtags=: Similarly, =helm-gtags= also has the command
  =helm-gtags-show-stack= that shows visited tags from newest to
  oldest, from top to bottom.

* Source code completion
:PROPERTIES:
:ID:       419c04f5-95b6-4457-83fe-9288361e7bcf
:END:
** Using CEDET
:PROPERTIES:
:ID:       60d03387-8a9b-42be-981c-58fca82d7a70
:END:
*** What is CEDET?
:PROPERTIES:
:ID:       5e06a903-4853-4093-a5b0-b5b28b3a6eaa
:END:
CEDET is a (C)ollection of (E)macs (D)evelopment (E)nvironment (T)ools written
with the end goal of creating an advanced development environment in
Emacs. CEDET includes common features such as intelligent completion,
source code navigation, project management, code generation with
templates . CEDET also provides a framework for working with
programming languages; support for new programming languages can be
added and use CEDET to provide IDE-like features.

This tutorial only helps you use CEDET to get completion feature for
C/C++.

*** Why use CEDET?
:PROPERTIES:
:ID:       b8922b61-b52a-4690-8626-4ca463dd2f85
:END:
CEDET is simple to setup and portable (right winthin Emacs and written
entirely with Emacs Lisp). Without CEDET, you have to use external
tools and third party Emacs packages. The downside of external tools
is that they are not specifically designed for Emacs. They have
similar use cases, but not always satisfying. For example, source code
indexing tools such as GNU Global and Exuberant Ctags are really good
at working static source code, but they do not keep track changes in
real time; CEDET does:

[[file:static/auto_complete.gif][file:static/auto_complete.gif]]

As you can see, CEDET recognizes when =printk.h= is included and
provides appropriate completion candidates. In contrast, non-context
sentisve completion is like this:

[[file:static/c-ide/company-clang-company-gtags.gif][file:static/c-ide/company-clang-company-gtags.gif]]

In this case, the completion system gets all candidates straight from
GNU Global generated database without considering current context.

The disadvantage is that CEDET is written in Emacs Lisp, and it is
bound to the performance limitations of Emacs. Even though, CEDET is
still really fast for moderate-size source files. CEDET also makes use
of external tools like GNU Global or Cscope or Exuberant Ctags for
finding symbol references/definition in a project to reduce its
workload.

*** Semantic minor modes
:PROPERTIES:
:ID:       e57ff2d7-623a-4feb-91ac-c69487996527
:END:
=Semantic= is a package that provides language-aware editing commands
based on source code parsers. Parsing is a process of analyzing source
code based on programming language syntax. Emacs understands your
source code through this process to provides features such as
contextual code completion, code navigation.
***** Setup Semantic
:PROPERTIES:
:ID:       22bc4bb9-df93-4702-8b7d-9eb8b038059b
:END:
To enable code completion using Semantic, add the following code:

#+begin_src emacs-lisp
  (require 'cc-mode)
  (require 'semantic)

  (global-semanticdb-minor-mode 1)
  (global-semantic-idle-scheduler-mode 1)

  (semantic-mode 1)
#+end_src

***** Command: =semantic-mode=
:PROPERTIES:
:ID:       8f24eec1-81f5-445b-bdc7-1b7e27943ce5
:END:
This command activates =semantic-mode=. In Semantic mode, Emacs parses
the buffers you visit for their semantic content. The parsing looks
like this:

[[file:static/c-ide/semantic-parsing.gif][file:static/c-ide/semantic-parsing.gif]]

Notice that at the bottom, Emacs prints messages like this: =Parsing
<file> (LL)...<progress in percentage>=. This is common behavior of
=Semantic=: when you perform a jump to a symbol or perform a
completion, =Semantic= tries to be accurate by parsing all the
included files and all the included files in the included files and so
on, until it reaches the end:

You may worry that this process takes a long time. Sometimes, it
does. However, this is just a one time process. Once it is parsed,
Semantic will cache the parsing result for future use. The next time
you perform some action on the parsed code, such as code completion,
you will get your desired output instantly. Syntactic analyzing takes
time. Many people don't understand this process and assume that CEDET
is slow.

***** Command: =global-semanticdb-minor-mode=
:PROPERTIES:
:ID:       668b4f56-2977-4783-b7cb-b5d84a0dd769
:END:
As mentioned above, Semantic caches parsing result for future
use. To do that, =semanticdb-minor-mode= must be activated. In
Semantic DB mode, Semantic parsers store results in a database, which
can be saved for future Emacs sessions. The cache is saved in
directory specified by =semanticdb-default-save-directory=
variable. The default directory is =~/.emacs.d/semanticdb=.

***** Command: =global-semantic-idle-scheduler-mode=
:PROPERTIES:
:ID:       fb0dd2f4-78c0-4e9c-b9d7-0ec4caa3fde3
:END:
When =semantic-idle-scheduler-mode= is enabled, Emacs periodically
checks to see if the buffer is out of date, and reparses while the
user is idle (not typing). When this mode is off, a buffer is only
reparsed when user explicitly issue some command.

With =semantic-idle-scheduler-mode=, Emacs keeps track live changes of
your source code.

***** Package: =function-args=
:PROPERTIES:
:ID:       3e24664a-c6cc-44d5-b0ea-457a25590d38
:END:
[[https://github.com/abo-abo/function-args][function-args]] is a GNU Emacs package for showing an inline
arguments hint for the C/C++ function at point.

Setup:

#+begin_src emacs-lisp
  (require 'function-args)
  (fa-config-default)
  (define-key c-mode-map  [(tab)] 'moo-complete)
  (define-key c++-mode-map  [(tab)] 'moo-complete)
#+end_src

Basic Usage (taken from =function-args= homepage):

- =fa-show=: Show an overlay hint with current function arguments like
  so:

  [[file:static/c-ide/fa-show][file:static/c-ide/fa-show]]

  The point position is tracked and the current hint argument is
  updated accordingly. After you've called it with =M-i=, you can cycle
  the overloaded functions with =M-n/M-h=. You can dismiss the hint with
  =M-u= or by editing anywhere outside the function arguments.

- =fa-jump=: While the overlay hint from =fa-show= is active, jump to
  the current function. The default shortcut is =M-j=. If the overlay
  isn't active, call whatever was bound to =M-j= before (usually it's
  =c-indent-new-comment-line=).

- =moo-complete= (must install =helm=): It's essentially a
  c++-specific version of semantic-ia-complete-symbol. It behaves
  better, because it accounts more for function overloading and
  inheritance. Also it's prettier (type parts are fontified) and
  faster (helm is used for completion). You can invoke it with =M-o=
  by default.

  [[file:static/c-ide/moo-complete.png][file:static/c-ide/moo-complete.png]]

There are a few more commands. You can view all the descriptions for
all commands [[https://github.com/abo-abo/function-args#main-functions][here]].

***** Package: =company=
:PROPERTIES:
:ID:       3b617d5a-5957-4f87-be20-4241ba8b827a
:END:
You can also use =company= for code completion. After installing
=company= from MELPA, activate it globally:

#+begin_src emacs-lisp
  (require 'company)
  (add-hook 'after-init-hook 'global-company-mode)
#+end_src

Please read the *Usage* section on [[http://company-mode.github.io/][company homepage]] to learn company
general features. You have three commands for completing C/C++ code:

- =company-clang=: use =clang= to retrieve completion candidates.
- =company-semantic=: use =Semantic= to retrieve completion
  candidates. Function interface of each candidate is shown in the
  minibuffer.
- =company-gtags=: use GTAGS database from =GNU Global= to retrieve
  completion candidates.

***** Package: =company-c-headers=
:PROPERTIES:
:ID:       6e05e8a5-04a3-4279-bf99-22fd627c0e92
:END:
[[https://github.com/randomphrase/company-c-headers][company-c-headers]] provides auto-completion for C/C++ headers using
Company. After installing from MELPA, set it up:

#+begin_src emacs-lisp
  (add-to-list 'company-backends 'company-c-headers)
  (define-key c-mode-base-map (kbd "C-<tab>") 'company-c-headers)
#+end_src

[[file:static/c-ide/company-c-header.png][file:static/c-ide/company-c-header.png]]

*** CEDET can do more
:PROPERTIES:
:ID:       a4605a59-5c3f-4604-84ce-6f22f15ea8bc
:END:
This guide only covers a portion of CEDET. Since Semantic parses
source code and creates a database for code  completion, it would be
useful to reuse the database for other features such as code
navigation, jump to definition and gather references. These are cool
features. For example, CEDET provide nice syntax highlighting for
gathering references:

[[file:static/c-ide/semantic-symref.gif][file:static/c-ide/semantic-symref.gif]]

The above feature is called Semantic Symref. It queries tag references
from SemanticDB and display the result in another buffer. Please
refer to [[https://www.gnu.org/software/emacs/manual/html_node/semantic/SymRef.html][GNU Manual - Symbol References]] for more info. If your project
is only the size of Emacs or similar, then Semantic Symref is a viable
choice. Remember that when entering new files, Semantic takes time to
parse and if you gather references for the first time, you will have
to wait for a while for Semantic doing its job. After the first time,
subsequent uses of Semantic Symref happens instantly.

But, for navigating around the source tree, we already have =ggtags=
and =helm-gtags=, which uses GNU Global for much faster indexing for
large project like Linux kernel. The only thing that other tools
cannot do, is context-sensitive completion. That's why we only use
CEDET for code completion in this guide. Nevertheless, Semantic Symref
is still a viable choice for small to medium sized projects. Choose
the one you prefer.

Other solutions that use =clang= is quite good but not there yet. For
example, [[https://github.com/brianjcj/auto-complete-clang][auto-complete-clang]] is fine for getting system header
candidates (since =clang= has system paths by default), but it has no
concept of project and is not aware of project include path. You can
add more arbitrary include paths to [[https://github.com/brianjcj/auto-complete-clang][auto-complete-clang]], but it won't
be pretty: once you add an include path for a project, it is visible
to all other projects since the include path is treat as system
include path. That means, whenever you try to complete something, you
get irrelevant candidates from other projects as well. Quite
annoying. =company-clang= also has the same problem. Another solution
is [[https://github.com/Andersbakken/rtags][rtags]], but it is really complicated to setup, especially if you use
=make=; I never succeed with it. =clang= based packages still have a
long way to go. CEDET also supports =clang= for retrieving completion
candidates. It also has the limitations of other packages.

CEDET is best used with new project, because Semantic parse code as
you write. As a result, you won't have to wait for parsing unknown
source files to get completion candidates.

* Project management with EDE
:PROPERTIES:
:ID:       d837c3b1-b5ca-4871-9b7b-cf5d24b2f8dd
:END:
EDE, short for Emacs Development Environment, is a generic interface
for managing projects. In EDE, a project hierarchy matches a directory
hierarchy. The project's topmost directory is called the project root,
and its subdirectories are sub-projects.

EDE can do many things but we will just use it for code completion at
project level. To demonstrate the use of EDE, we will create a little
project of our own.

To setup EDE:

#+begin_src emacs-lisp
  (require 'ede)
  (global-ede-mode)
#+end_src


- First, create this directory structure (I assume you know how to
  manage directory with Dired):

#+begin_src fundamental
  project_root/
              Makefile
              src/
                  feature1/
              include1/
                  feature1/
              include2/
#+end_src

Then, create files: =lib1.c=, =lib2.c=, =lib1.h=, =lib2.h=,
=feature1.h=, =feature1.c= and =main.c=. For the =.h= files, create
them using this template

#+begin_src c
  void filename_func1();
  int filename_func2(int a, int b);
#+end_src

Replace =filename= or =FILENAEM= with actual filename like =lib1=.

For =.c= files, except for =main.c=, create them according to this
template:

#+begin_src c
  #include "filename.h"

  void filename_func1() { }

  int filename_func2(int a, int b) { }
#+end_src

The files look silly but good enough for our learning purpose. Now, in
=main.c=, let's test auto-completion by including appropriate header
file:

[[file:static/c-ide/ede-same-dir-completion.gif][file:static/c-ide/ede-same-dir-completion.gif]]

Everything works fine when all files are under the same
directory. Let's split the files into different directories we created
before, like this:

#+begin_src fundamental
  project_root/
              Makefile
              src/
                  main.c
                  lib.c
                  lib2.c
                  feature1/
                      feature1.c
              include1/
                  lib.h
                  feature1/
                      feature1.h
              include2/
                  lib2.h
#+end_src

[[file:static/c-ide/ede-rearrange-project-dir.gif][file:static/c-ide/ede-rearrange-project-dir.gif]]

Try auto-completion again. This time, it won't work. No candidate is
displayed. It is because Semantic only looks for header files in
current directory by default. If you put it elsewhere, you have to
tell Semantic where it is. This is not limited to only Semantic; you
have to specify project include path in Eclipse as well.

- Create a new file called =cedet-projects.el= in =~/.emacs.d/=.
- In this file, add a new =ede-cpp-root-project= in this form:

#+begin_src emacs-lisp
  (ede-cpp-root-project "project_root"
                        :file "/dir/to/project_root/Makefile")
#+end_src

The first argument to =ede-cpp-root-project= is project name. =:file=
argument specifies path to project root. You must create a file in the
project root, since EDE uses that file as an "anchor" to project
root; in our case, =Makefile= is the anchor file. Not sure why EDE
just straightly uses root directory.

- Add include directories specific to the project and in your system:

#+begin_src emacs-lisp
  (ede-cpp-root-project "project_root"
                        :file "/dir/to/project_root/Makefile"
                        :include-path '("/include1"
                                        "/include2") ;; add more include paths here
      :system-include-path '("~/linux"))
#+end_src

=:include-path= specifies directories local to your projects that EDE
should search first when looking for a header file. =:incluide-path=
is relative to project root specified in =:file=.

=:system-include-path= specifies system include paths that do not
belong to current project. Note that despite it is called
=system-include-path=, it does not have to be in place like
=/usr/include=. You can specify any include directories outside of
your current project as "system headers".

After done setting up your project, save the file and execute that
=ede-cpp-root-project= expression with *C-x C-e*. Now, Semantic is
aware of your project include paths. However, you have to do one last
thing: either close the file =main.c= and reopen it or =M-x
semantic-force-refresh= to tell Semantic to analyze =main.c=
again. Otherwise, Semantic will still keep the previous parsing result
of this file and completion candidates won't be available. As a
result, it is important to load EDE projects defined by
=ede-cpp-root-project= before opening any project file.

After that, try auto-completion and you will see everything is working
fine again:

[[file:static/c-ide/ede-project.gif][file:static/c-ide/ede-project.gif]]

Summary:

- EDE, short for Emacs Development Environment, is a generic interface
  for managing projects.
- EDE enables Semantic to find sources and perform project level
  completions.
- To add a C/C++ project, simply create a project definition with this
  template in a file, such as =ede-projects.el=:

#+begin_src emacs-lisp
  (ede-cpp-root-project "project_root"
                        :file "/dir/to/project_root/Makefile"
                        :include-path '("/include1"
                                        "/include2") ;; add more include paths here
      :system-include-path '("~/linux"))
#+end_src

- Load =ede-projects.el= when Emacs start.
- If you have opening files, either close or refresh it with =M-x
  semantic-force-refresh= to make Semantic aware of new changes.

* Source code information
:PROPERTIES:
:ID:       7401e60b-1f91-4697-814c-1e72f395dfdd
:END:
** Command: =global-semantic-idle-summary-mode=
:PROPERTIES:
:ID:       8d06ed59-5a1a-49eb-8ea6-d3411c35b0fe
:END:
This mode, when enabled, displays function interface in the
minibuffer:

[[file:static/func_args.jpg][file:static/func_args.jpg]]

It works well for C but not C++, since C++ can overload function and
=semantic-idle-summary-mode= can only display one interface at a
time. Since this mode is part of Semantic, it also relies on
SemanticDB that is created from parsing source files.

Setup:

#+begin_src emacs-lisp
  (global-semantic-idle-summary-mode 1)
#+end_src

** Command: =global-semantic-stickyfunc-mode=
:PROPERTIES:
:ID:       50dc542d-dca8-425d-9646-083ce3ca8ae8
:END:
When enable, this mode shows the function point is currently in at the
first line of the current buffer. This is useful when you have a very
long function that spreads more than a screen, and you don't have to
scroll up to read the function name and then scroll down to original
position.

[[file:static/c-ide/semantic-sticky-func.gif][file:static/c-ide/semantic-sticky-func.gif]]

Setup:

#+begin_src emacs-lisp
  (global-semantic-stickyfunc-mode 1)
#+end_src

** Using =ggtags= + =eldoc=
:PROPERTIES:
:ID:       81db4e8e-f913-4b5c-87e4-74d90e80aaa9
:END:
You can also use =ggtags= for displaying function interface at point
in minibuffer:

#+begin_src emacs-lisp
  (setq-local eldoc-documentation-function #'ggtags-eldoc-function)
#+end_src

However, it won't have syntax highlighting.

* Source code editing
:PROPERTIES:
:ID:       0fa2afe0-728c-49f6-86f1-7769cebc5de0
:END:
** Folding
:PROPERTIES:
:ID:       48b6ad5f-24e2-41c3-9a44-c1decdde6910
:END:
Emacs has a minor mode called =hs-minor-mode= that allows users to
fold and hide blocks of text. Blocks are defined by regular
expressions which match the start and end of a text region. For
example, anything in between ={= and =}= is a block. The regular
expressions are defined in =hs-special-modes-alist=.

Setup for C/C++:

#+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook   'hs-minor-mode)
#+end_src

Default key bindings:

| Key           | Binding                                    |
|---------------+--------------------------------------------|
| *C-c @ C-c*   | Command: =hs-toggle-hiding=                |
|               | Toggle hiding/showing of a block           |
|---------------+--------------------------------------------|
| *C-c @ C-h*   | Command: =hs-hide-block=                   |
|               | Select current block at point and hide it  |
|---------------+--------------------------------------------|
| *C-c @ C-l*   | Command: =hs-hide-level=                   |
|               | Hide all block with indentation levels     |
|               | below this block                           |
|---------------+--------------------------------------------|
| *C-c @ C-s*   | Command: =hs-show-block=                   |
|               | Select current block at point and show it. |
|---------------+--------------------------------------------|
| *C-c @ C-M-h* | Command: =hs-hide-all=                     |
|               | Hide all top level blocks, displaying      |
|               | only first and last lines.                 |
|---------------+--------------------------------------------|
| *C-c @ C-M-s* | Command: =hs-show-all=                     |
|               | Show everything                            |
|---------------+--------------------------------------------|

Demo:

- Command: =hs-toggle-hiding=

[[file:static/c-ide/hs-toggle-hiding.gif][file:static/c-ide/hs-toggle-hiding.gif]]

** Narrowing
:PROPERTIES:
:ID:       000644fa-84e8-42a2-b780-6ff1b0c84a5a
:END:
Narrowing means making only a text portion in current buffer
visible. Narrowing is useful when you want to perform text editing on
a small part of the buffer without affecting the others. For example,
you want to delete all =printf= statements in current functions, using
=flush-lines= command. But if you do so, you will also delete =printf=
outside the current function, which is undesirable. By narrowing, you
can safely remove all those =printf= and be certain that nothing else
is changed accidentally.

Default key bindings:

| Key       | Binding                                    |
|-----------+--------------------------------------------|
| *C-x n d* | Command: =narrow-to-defun=                 |
|           | Narrow buffer to current function at point |
|-----------+--------------------------------------------|
| *C-x n r* | Command: =narrow-to-region=                |
| *C-x n n* | Narrow buffer to active region             |
|-----------+--------------------------------------------|
| *C-x n w* | Command: =widen=                           |
|           | Widen buffer                               |
|-----------+--------------------------------------------|

** Identation
:PROPERTIES:
:ID:       2c98c4cb-0db4-4f27-9b39-d5f972cbe51a
:END:
*** Setup default C style
:PROPERTIES:
:ID:       6dd8b948-f101-4a7c-8fd8-9b836474df17
:END:
Emacs offers some popular C coding styles. Select the one suitable for
you:

#+begin_src emacs-lisp
    ;; Available C style:
    ;; “gnu”: The default style for GNU projects
    ;; “k&r”: What Kernighan and Ritchie, the authors of C used in their book
    ;; “bsd”: What BSD developers use, aka “Allman style” after Eric Allman.
    ;; “whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
    ;; “stroustrup”: What Stroustrup, the author of C++ used in his book
    ;; “ellemtel”: Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,” Erik Nyquist and Mats Henricson, Ellemtel
    ;; “linux”: What the Linux developers use for kernel development
    ;; “python”: What Python developers use for extension modules
    ;; “java”: The default style for java-mode (see below)
    ;; “user”: When you want to define your own style
    (setq
     c-default-style "linux" ;; set style to "linux"
     )
#+end_src

*** Setup indentation
:PROPERTIES:
:ID:       394da0e4-4995-4583-9b67-2611f3352d3b
:END:
By default, Emacs won't indent when press *RET* because the command
bound to *RET* is newline. You can enable automatic indentation by
binding *RET* to =newline-and-indent=.

#+begin_src emacs-lisp
    (global-set-key (kbd "RET") 'newline-and-indent)  ; automatically indent when press RET
#+end_src

When working with source code, we must pay attention to trailng
whitespace. It is always useful to view whitespace in current buffer
before committing your code.

#+begin_src emacs-lisp
  ;; activate whitespace-mode to view all whitespace characters
  (global-set-key (kbd "C-c w") 'whitespace-mode)

  ;; show unncessary whitespace that can mess up your diff
  (add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))

  ;; use space to indent by default
  (setq-default indent-tabs-mode nil)

  ;; set appearance of a tab that is represented by 4 spaces
  (setq-default tab-width 4)
#+end_src

To clean up trailing whitespace, you can also run =whitespace-cleanup=
command.

To convert between *TAB* and *space*, you also have two commands:
=tabify= to turn an active region to use *TAB* for indentation, and
=untabify= to turn an active region to use *space* for indentation.

*** Package: =clean-aindent-mode=
:PROPERTIES:
:ID:       12c0c0ee-66ea-411b-aa7c-0b437c4bc89d
:END:
When you press *RET* to create a newline and got indented by
=eletric-indent-mode=, you have appropriate whitespace for
indenting. But, if you leave the line blank and move to the next line,
the whitespace becomes useless. This package helps clean up unused
whitespace.

View this [[http://www.emacswiki.org/emacs/CleanAutoIndent][Emacswiki page]] for more details.

#+begin_src emacs-lisp
  ;; Package: clean-aindent-mode
  (require 'clean-aindent-mode)
  (add-hook 'prog-mode-hook 'clean-aindent-mode)
#+end_src

*** Package: =dtrt-indent=
:PROPERTIES:
:ID:       ce57a6b0-79c6-46c2-9fb2-3fb0cb3bd9c0
:END:
A minor mode that guesses the indentation offset originally used for
creating source code files and transparently adjusts the corresponding
settings in Emacs, making it more convenient to edit foreign files.

This package is really useful when you have to work on many different
projects (for example, your project consists of many git submodules)
that use different indentation format. One project might use *TAB*
for indentation; another project might use *space* for
indentation. Having to manually switch between *TAB* and *space* is
tiresome. We should let Emacs take care of it automatically. This
package does exactly that. However, if a project mixes *TAB* and
*space*, then the package will have a hard time to detect. But then
again, if you work on such project, it doesn't matter anyway.

Setup:

#+begin_src emacs-lisp
  ;; Package: dtrt-indent
  (require 'dtrt-indent)
  (dtrt-indent-mode 1)
#+end_src

*** Package: =ws-butler=
:PROPERTIES:
:ID:       65c42593-e1b3-4061-8ae8-276f29258d01
:END:
=ws-butler= helps managing whitespace on every line of code written or
edited, in an unobtrusive, help you write clean code without noisy
whitespace effortlessly. That is:

- Only lines touched get trimmed. If the white space at end of buffer
  is changed, then blank lines at the end of buffer are truncated
  respecting require-final-newline.

- Trimming only happens when saving.

With =clean-aindent-mode= and =dtrt-indent= and =ws-butler=, you
could totally forget about whitespace. If you are careful, turn on
=whitespace-mode= (bound to =C-c w= above) and check for whitespace
before committing.

Setup:

#+begin_src emacs-lisp
    ;; Package: ws-butler
  (require 'ws-butler)
  (add-hook 'prog-mode-hook 'ws-butler-mode)
#+end_src

** Code template using =yasnippet=
:PROPERTIES:
:ID:       3952aed5-31ed-4715-a892-9f55056fe98d
:END:
YASnippet is a template system for Emacs. It allows you to type an
abbreviation and automatically expand it into function
templates. Bundled language templates include: C, C++, C#, Perl,
Python, Ruby, SQL, LaTeX, HTML, CSS and more. The snippet syntax is
inspired from TextMate's syntax, you can even import most TextMate
templates to YASnippet.

Setup:

#+begin_src emacs-lisp
  ;; Package: yasnippet
  (require 'yasnippet)
  (yas-global-mode 1)
#+end_src

_Usage_:

In major modes where *yasnippet* has snippets available,
typing a certain keyword and *TAB* insert a predefined snippet. For
example, in a C buffer, if you type =for= and *TAB*, it expands to:

#+begin_src c
  for (i = 0; i < N; i++) {
      ...point will be here....
  }
#+end_src

You can view supported snippets [[https://github.com/AndreaCrotti/yasnippet-snippets/tree/master][here]].

** Package: =smartparens=
:PROPERTIES:
:ID:       62b4b86b-222f-4915-834e-b3d79b73f9f0
:END:
=smartparens= is a minor mode that provides many features for
manipulating pairs. Pair can be simple as parentheses or brackets, or
can be programming tokens such as =if= ... =fi= or =if= ... =end= in
many languages. The most basic and essential feature is automatic
closing of a pair when user inserts an opening one.

#+begin_src emacs-lisp
    ;; Package: smartparens
  (require 'smartparens-config)
  (show-smartparens-global-mode +1)
  (smartparens-global-mode 1)
#+end_src

For complete documentation, please refer to [[https://github.com/Fuco1/smartparens/wiki#information-for-new-users][Smartparens manual]].

* Compilation Support
:PROPERTIES:
:ID:       28a612e9-d3f2-47be-acbb-91aeb9b32466
:END:
 Compilation mode turns each error message in the buffer into a
 hyperlink. You can click on each error, or execute a key binding like
 *RET* to jump to the location of that error.

 The following key bindings are available:

| Key     | Description                                                                     |
|---------+---------------------------------------------------------------------------------|
| *C-o*   | Display matched location, but *do not* switch point to matched buffer           |
|---------+---------------------------------------------------------------------------------|
| *M-n*   | Move to next error message, but *do not* visit error location                   |
|---------+---------------------------------------------------------------------------------|
| *M-p*   | Move to next previous message, but *do not* visit error location                |
|---------+---------------------------------------------------------------------------------|
| *M-g n* | Move to next error message, visit error location                                |
|---------+---------------------------------------------------------------------------------|
| *M-g p* | Move to previous error message, visit error location                            |
|---------+---------------------------------------------------------------------------------|
| *RET*   | Visit location of error at poiint                                               |
|---------+---------------------------------------------------------------------------------|
| *M-{*   | Move point to the next error message or match occurring in a different file     |
|---------+---------------------------------------------------------------------------------|
| *M-}*   | Move point to the previous error message or match occurring in a different file |
|---------+---------------------------------------------------------------------------------|
| *q*     | Quit =*compilation*= buffer                                                     |
|---------+---------------------------------------------------------------------------------|

I usually execute the same compilation command many times. It's more
convenient if Emacs doesn't ask us to confirm every time we re-execute
a command:

#+begin_src emacs-lisp
  (global-set-key (kbd "<f5>") (lambda ()
                                 (interactive)
                                 (setq-local compilation-read-command nil)
                                 (call-interactively 'compile)))
#+end_src

If you want to enter a new command, add prefix argument before
pressing =<f5>=.

Demo:

[[file:static/c-ide/compilation-mode.gif][file:static/c-ide/compilation-mode.gif]]

As you can see, output in =*compilation*= buffer looks much better
than in plain terminal with colors and you can also interact with it.

You can also run other shell commands in here, not just compilation
commands. A really cool thing with =compilation-mode= is that it is
asynchronous. That is, if your source files contain errors, you don't
have to wait for the whole compilation process to finish. You can
examine the errors right away in the =*compilation*= buffer, while the
compilation process keeps going.

*TIP*: It is useful to open a Dired buffer of the project root and
store a window configuration that contains it into a register, so you
can always jump back to project root any where, any time and run
compilation command. If you do not use know how to use registers to
store window configurations, read it [[file:emacs-tutor.org::*Registers][here]].

* Debugging with GDB Many Windows
:PROPERTIES:
:ID:       a13b3e48-d73c-4fc4-97c3-b9f1d5814e63
:END:
Emacs has built-in frontend support for GDB that provides IDE-like
interface. It has a layout like this:

[[file:static/c-ide/gdb-many-windows.gif][file:static/c-ide/gdb-many-windows.gif]]

Stock Emacs doesn't enable this layout by default. You have to
tell Emacs to always use =gdb-many-windows=:

#+begin_src emacs-lisp
  (setq
   ;; use gdb-many-windows by default
   gdb-many-windows t

   ;; Non-nil means display source file containing the main routine at startup
   gdb-show-main t
   )
#+end_src

Now, find a binary built for debugging, and start GDB by =M-x
gdb=. Emacs prompts asking you how to run =gdb=. By default, the
prompt looks like this:

[[file:static/c-ide/gdb-prompt.gif][file:static/c-ide/gdb-prompt.gif]]

To use =gdb-many-windows=, you must always supply the *-i=mi* argument
to gdb, otherwise =gdb-many-windows= won't work. By default, as you've
seen the layout of =gdb-many-windows= above, you have the following
buffers visible on your screen (ignore the first row):

|                           |                                     |
|---------------------------+-------------------------------------|
| 1. GUD interaction buffer | 2. Locals/Registers buffer          |
|---------------------------+-------------------------------------|
| 3. Primary Source buffer  | 4. I/O buffer for debugging program |
|---------------------------+-------------------------------------|
| 5. Stack buffer           | 6. Breakpoints/Threads buffer       |
|---------------------------+-------------------------------------|

Each cell coressponds to the following commands:

- =gdb-display-gdb-buffer= *(Cell 1)*: This is where you enter =gdb=
  commands, the same as in terminal. When you kill this buffer, other
  GDb buffers are also killed and debugging session is terminated.

- =gdb-display-locals-buffer= *(Cell 2)*: display local variables and
  its values in current stack frame. Please refer to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Source-Buffers.html#Source-Buffers][GNU Manual -
  Other GDB Buffers]] for usage of the buffer.

- =gdb-display-registers-buffer= *(Cell 2)*: registers values are
  displayed here. Please refer to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Source-Buffers.html#Source-Buffers][GNU Manual - Other GDB Buffers]] for
  usage of the buffer.

- Your source buffer *(Cell 3)*: Your source code for stepping through
  out the debugging session. Please refer to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Source-Buffers.html#Source-Buffers][GNU Manual - Source
  Buffers]] for usage of the buffer.

- =gdb-display-io-buffer= *(Cell 4)*: This is where your program
  displays output and accepts input. In stock GDB (Command Line
  Interface), you enter input whenever a program asks for one under
  GDB prompt. Using =gdb-many-windows=, *you must enter program input
  here*.

- =gdb-display-stack-buffer= *(Cell 5)*: Display function call
  stack. Please refer to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Stack-Buffer.html#Stack-Buffer][GNU Manual - Stack buffer]] for usage.

- =gdb-display-breakpoints-buffer= *(Cell 6)*: Display a list of
  breakpoints. Please refere to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Breakpoints-Buffer.html#Breakpoints-Buffer][GNU Manual - Breakpoints Buffer]] for
  usage of the buffer.

- =gdb-display-threads-buffer= (Cell 6): Display running threads in
  your programs. Please refer to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Threads-Buffer.html#Threads-Buffer][GNU Manual - Threads Buffer]] and
  [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Multithreaded-Debugging.html#Multithreaded-Debugging][Multithreaded Debugging]] for usage of the buffer. 

There are two useful commands that are not visible in
=gdb-many-windows=:

- =gdb-display-disassembly-buffer=: displays the current frame as
  assembly code.
- =gdb-display-memory-buffer=: displays a portion of program memory.

There are another variants of the above buffers, with =gdb-frame=
prefix instead of =gdb-display=. When you run commands with
=gdb-frame= prefix, the buffers are opened in a new frame instead of
occupying an existing window. This is useful when you have 2 monitors,
one is for the standard =gdb-many-windows= layout and another one is
for displaying disassembly buffer and memory buffer in a separate
frame.
