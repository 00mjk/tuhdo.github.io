#+TITLE:
_Author_:

- Tamas Patrovic (past maintainer), from 2007.
- rubikitch =rubikitch@ruby-lang.org=, from 2008-2011.
- [[https://github.com/thierryvolpiatto][Thierry Volpiatto]] (current
  maintainer). =thierry.volpiatto@gmail.com=, from 2011-present.

_Homepage_: [[https://github.com/emacs-helm/helm][Github]]

_Features_:

=Helm= is incremental completion and selection narrowing framework for
Emacs. It will help steer you in the right direction when you're
looking for stuff in Emacs (like buffers, files, etc).

Helm is a fork of =anything.el= originally written by Tamas Patrovic and
can be considered to be its successor. =Helm= sets out to clean up the
legacy code in =anything.el= and provide a cleaner, leaner and more
modular tool, that's not tied in the trap of backward compatibility.

_Installation_:

=M-x list-packages= and select *helm* package, then
install it. After finish installing, add this code snippet to activate
the package:

Minimal config:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: helm              ;;
  ;;                            ;;
  ;; GROUP: Convenience -> Helm ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'helm-config)
  (helm-mode 1)
#+end_src

My extended config:

#+begin_src emacs-lisp
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: helm              ;;
  ;;                            ;;
  ;; GROUP: Convenience -> Helm ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'helm)
  (require 'helm-config)
  (require 'helm-eshell)
  (require 'helm-files)
  (require 'helm-grep)

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebihnd tab to do persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

  (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
  (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
  (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)

  (setq
   helm-google-suggest-use-curl-p t
   helm-scroll-amount 4 ; scroll 4 lines other window using M-<next>/M-<prior>
   helm-quick-update t ; do not display invisible candidates
   helm-idle-delay 0.01 ; be idle for this many seconds, before updating in delayed sources.
   helm-input-idle-delay 0.01 ; be idle for this many seconds, before updating candidate buffer
   helm-ff-search-library-in-sexp t ; search for library in `require' and `declare-function' sexp.

   ;; you can customize helm-do-grep to execute ack-grep
   ;; helm-grep-default-command "ack-grep -Hn --smart-case --no-group --no-color %e %p %f"
   ;; helm-grep-default-recurse-command "ack-grep -H --smart-case --no-group --no-color %e %p %f"
   helm-split-window-default-side 'other ;; open helm buffer in another window
   helm-split-window-in-side-p t ;; open helm buffer inside current window, not occupy whole other window
   helm-buffers-favorite-modes (append helm-buffers-favorite-modes
                                       '(picture-mode artist-mode))
   helm-candidate-number-limit 200 ; limit the number of displayed canidates
   helm-M-x-requires-pattern 0     ; show all candidates when set to 0
   helm-boring-file-regexp-list
   '("\\.git$" "\\.hg$" "\\.svn$" "\\.CVS$" "\\._darcs$" "\\.la$" "\\.o$" "\\.i$") ; do not show these files in helm buffer
   helm-ff-file-name-history-use-recentf t
   helm-move-to-line-cycle-in-source t ; move to end or beginning of source
                                          ; when reaching top or bottom of source.
   ido-use-virtual-buffers t      ; Needed in helm-buffers-list
   helm-buffers-fuzzy-matching t          ; fuzzy matching buffer names when non--nil
                                          ; useful in helm-mini that lists buffers
   )

  (define-key helm-map (kbd "C-x 2") 'helm-select-2nd-action)
  (define-key helm-map (kbd "C-x 3") 'helm-select-3rd-action)
  (define-key helm-map (kbd "C-x 4") 'helm-select-4rd-action)

  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "C-c h m") 'helm-man-woman)
  (global-set-key (kbd "C-c h g") 'helm-do-grep)
  (global-set-key (kbd "C-c h f") 'helm-find)
  (global-set-key (kbd "C-c h l") 'helm-locate)
  (global-set-key (kbd "C-c h o") 'helm-occur)
  (global-set-key (kbd "C-c h r") 'helm-resume)
  (define-key 'help-command (kbd "C-f") 'helm-apropos)
  (define-key 'help-command (kbd "r") 'helm-info-emacs)

  ;; use helm to list eshell history
  (add-hook 'eshell-mode-hook
            #'(lambda ()
                (define-key eshell-mode-map (kbd "M-l")  'helm-eshell-history)))

    ;;; Save current position to mark ring
  (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)

  (helm-mode 1)
#+end_src

_Usage_:

After using Helm, you are going to have a big change in the way you
use Emacs. After getting used to the Helm way, you don't want to leave
it. However, if you don't like Helm, you can still use Ido, which is
introduted in later section. Let's learn how to use helm by play with
it.

Completion with Helm is very different with the usual Emacs
completion:

- You type something.

- Instead of *TAB* to expand the common part until you find your
  candidates, in Helm, you type a parts of the candidate you want to
  search, separated by spaces. In Helm, these strings are called
  *patterns*.

- Helm will try to search and sort according to highest match, from
  top to bottom. The best match is at the top, so you can press *RET*
  and select it.

- You can navigate the buffer with *C-n* and *C-p* or *<up>* and
  *<down>* to move up/down, *C-v* and *M-v* to move to next/previous
  pages, and *M-<* and *M->* to move to top and bottom of the Helm
  buffer.

- You can also mark candidates with *C-SPC*; this is useful when you
  need to perform an action on many candidates of your choice. *M-a*
  to select all.

You can practice the above commands with *C-x b*, whicn runs
=helm-mini=. If you mark more than one buffers, *RET* opens the
selected buffers.

*_IMPORTANT_*: /Please remember that, when you use Helm, you never *TAB*/
/to complete prefixes like vanilla or other packages like Ido and its/
/related packages. In Helm, when you type something, candidates get/
/updated *automatically*. In vanilla Emacs, you have to *TAB* to get a//
/list of candidate. This is a great feature from Helm, not a miss of/
/feature. You have to forget the mentally of *TABBING* to get/
/candidates. If you want quick completion of search patterns in Helm/
/prompt, you always have =hippie-expand= to replace the *TAB*/
/behaviour, as introduced at the beginning of this section. This is/
/the biggest confusion for new people switching to Helm. When you are/
/used to Helm, you will love it./

When you execute a Helm command, you enter a Helm session. A Helm
session is a dedicated state to working with Helm features; while in a
Helm session, a dedicated Helm buffer is always opened. When you quit
a Helm session, a Helm buffer is closed. In Helm, you basically need
to remember the 3 commands:

- Access to action menu with *TAB*. An action is a command to run on
  marked candidates (one or more) and quit current Helm session; an
  action menu is a text-based menu that lists actions you can
  take. For example, =Find File= (open file), =Find File in Dired=,
  =Grep File=...

- *C-z* executes *helm-execute-persistent-action*; a persistent action
  is an action that you use in a Helm session without quitting the
  session.

- In some Helm session, such as =helm-find-files= or =helm-mini=, you
  can select more than one candidates and execute actions on them,
  such as =grep= or =open=.

However, for convenience, let's *TAB* with *C-z* in the above
settings, so we can use *TAB* more comfortably, because you actually
use *helm-execute-persistent-action* more than
*helm-select-action* by adding the code snippet below:

#+begin_src emacs-lisp
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebihnd tab to do persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
#+end_src

In a Helm session, if you need help, use *C-c ?*, or refer to this
manual again. The commands in the key bindings above are good enough
to help you using Helm productively.

*** Operate on text at point:
:PROPERTIES:
:ID:       8de25a41-da8b-42b5-b152-e62ef75d2bfd
:END:
If you are already in a Helm session, you can still get input from the
current editing buffer by the following key bindings:

- *C-w* yanks word at point, starting from point to the end of the
  word, into the Helm prompt (the minibuffer).
- *M-n* yanks symbol at point

Help commands also automatically recognize symbols at point if such
symbols exist in Emacs. For example:

- *C-h f*, which runs =describe-function=, automatically takes the
  symbol at point as default for searching function.
- *C-h v*, which runs =describe-variable=, automatically takes the
  symbol at point as default for searching variable.
- *C-h w*, which runs =where-is=, automatically takes the
  symbol at point as default for showing key binding for a command.
- ... and so on... (*C-h C-h* to view all commands)

*** Command: =helm-M-x=:
:PROPERTIES:
:ID:       500a1c68-ab43-40a5-97c3-5d556a9f748d
:END:

=M-x= and see the difference. You will see a buffer that lists
commands in Emacs. Some of you may not like it because it seems
overkill at first. However, even if you really don't like, please bear
with me until the end.

Now, type =li pa=; that's right =li= , a space and =pa=. You will see,
=list-packages= is at the top. Surprise! Let's try another input. Now,
type =pa ^li=, and you will receive =list-package= as the first
entry.

=helm-M-x= is also better then the default =M-x=, because it provides
key bindings right next to the commands, and *TAB* provides you the
built-in documentation of that command in another buffer.

*NOTE*: You have to bind =helm-M-x= to *M-x* manually. Otherwise, you
 still get Helm completion, but using the vanilla *M-x* that does not
 provides the above features like showing key bindings and *TAB* to
 open built-in documentation.

Demo:

[[file:static/part3/helm-m-x.gif][file:static/part3/helm-m-x.gif]]

*** Command: =helm-show-kill-ring=
:PROPERTIES:
:ID:       77b4d145-c280-4ed4-98a7-d645fe1d18bf
:END:
Do you remember that =C-y= [[http://tuhdo.github.io/emacs-tutor.html#sec-7-15][cycle the kill ring]]? However, working with
default kill ring is painful because you have a burden to remember an
invisible thing, that is the kill ring, at which position you kill
what. To view the kill ring, you have to *C-h v* and type =kill-ring=
to see content of the kill ring, and it is not pretty.

=helm-show-kill-ring= solves this problem: Helm shows the kill ring in
a readable format and allows you to narrow down by entering
sub-strings of candidates. You are lifted the cognitive burden when
using the default =M-y=.

If you follow my Helm configuration, =M-y= binds to
=helm-show-kill-ring=. Try it and see! Much easier than the default.

=helm-kill-ring= in action (the demo starts when you see START in the
minibuffer):

[[file:static/part3/helm-kill-ring.gif][file:static/part3/helm-kill-ring.gif]]

*** Command: =helm-mini=
:PROPERTIES:
:ID:       0386c827-7f5d-4056-bf4d-8d0fc01fc1ab
:END:
This Helm command comprises of multiple sources:

- Current opening buffers, under the header =Buffers=.
- Recently opened files, under the header =Recentf=.
- Allow you to create a new buffer by pressing *RET*, under the header
  =Create Buffer=.

You can move back and forth between the groups by using *<left>* and
*<right>* arrow keys. Or you can just scroll down/up with *C-v* and
*M-v*.

You can filter out buffers by major mode using the query
=*<major-mode>=. For example, =*dired= narrows to only Dired
buffers. You can also filter out buffers that belong to a major mode
by adding =!= to the query. For example, =*!dired= select all buffers
that are not in Dired mode.

You can also select buffers in a specific directory by using the query
=/directory=. For example, =/.emacs.d/= narrows to buffers that are
only inside =.emacs.d=. Add =!= before the query for reverse
version. For example, =!/.emacs.d/= narrows to buffers not in
=.emacs.d=.

You can even use =helm-mini= to narrow to buffers that contains a
regexp in their contents, by using the query =@content=. For example,
you can select buffers that only contain the string "test":
=@test=. If you want to see the positions of the string in the
buffers, *C-s* while in =helm-mini= session to switch to
=helm-moccur=. You can mark buffers to search by *C-SPC* or you can
select all buffers by *M-a*.

Meaning of colors and prefixes for buffers:

- Remote buffers are prefixed with '@'.
- Red => Buffer have its file modified on disk by an external
  process.
- Indianred2 => Buffer exists but its file have been deleted.
- Orange => Buffer is modified and its file not saved to disk.
- Italic => A non--file buffer.

Some Emacs themes change the colors. You should check the
corresponding colour in your color themes.

Example:

- If I enter in pattern prompt: =*lisp ^helm @moc=, Helm will narrow
  down the list by selecting only buffers that are in lisp mode, start
  by helm and match "moc" in their contents.

- If I want to specify more than one major-mode, separate them with
  =,=, e.g =*!lisp,!sh,!fun= will list all buffers but the ones in
  lisp-mode, sh-mode and fundamental-mode.

- If I enter in pattern prompt: =*lisp ^helm moc=. Notice there is no
  =@= this time helm will look for lisp mode buffers starting by
  "helm" and have "moc" in their name.

- If I enter in pattern prompt: =*!lisp !helm= Helm will narrow down
  to buffers that are not in "lisp" mode and that do not match "helm".

- If I enter in pattern prompt: =/helm/ w3= Helm will narrow down
  buffers that are in any "helm" sub-directory and matching w3.

 =helm-mini= is like an interactive version of =ibuffer=.

Demo: Search for buffers that contain string "Answer", and transfer
the search patterns to =helm-moccur= for the exact matches (the demo
starts when you see START in the minibuffer):

[[file:static/part3/helm-mini.gif][file:static/part3/helm-mini.gif]]

*** Command: =helm-find-files=
:PROPERTIES:
:ID:       b71abd6c-cb29-4b64-a55f-29bd75937c11
:END:
=helm-find-files= is file navigation on steroid: 

- =helm-find-files= can fuzzy match candidates in current
  directory. e.g "fob" or "fbr" will complete "foobar".

- You can also execute persistent action, which binds to *C-z* (by
  default), or *TAB* if you use my configuration to view content of
  the buffer. Move the buffer up/down by *M-<next>* and
  *M-<prior>*.

- You can go up one directory level with *C-l*. *_NOTE_*: if you
  use *C-l*, Helm goes up one level and the cursor is on the directory
  you've just got out. If you want to go up and have the cursors on
  the parent directory, in Helm prompt, enter =../=.

- To create a directory, enter a new name that does not exist in the
  current directory and append =/= at the end. After you created a
  directory, Helm continues in that directory.

- To create a new file, enter a name and select the top row that has
  the symbol =[?]= next to it. By default, Helm always selects the
  first match in the directory.

- You can invoke =grep= on the current highlighting entry by
  *C-s*. *C-u C-s* to perform recursive grep.

- Enter =~/= at end of pattern to quickly reach home directory.

- Enter =/= at end of pattern to quickly reach root of your file system.

- Enter =./= at end of pattern to quickly reach `default-directory'
  (initial start of session). If you are in `default-directory' move
  cursor on top.

You can perform more actions on the highlighting entry by running
=helm-select-action=, which is bound to *TAB* by default and *C-z* in
my configuration.

Demo: I only needed to type into the prompt a few character to get the
candidate I wanted among many candidates. The demo starts when you
see START in the minibuffer:

[[file:static/part3/helm-find-files.gif][file:static/part3/helm-find-files.gif]]

*_Find file at piont_*:

Do you know the feature =ffap=? I wrote it in part 1, but here is the
demo:

[[file:static/ffap.gif][file:static/ffap.gif]]

=helm-find-files= can do that too: all you need to do is moving your
point on a proper filepath, and Helm will reach the correct path for
you, similar to the screenshot. Now, you have no longer to use a
separate command for open file at point, but using the same *C-x
C-f*. It's really convenient.

*** Command: =helm-man-woman=
:PROPERTIES:
:ID:       2578b1bd-7ae9-4250-b701-c9191603404f
:END:
With =helm-man-woman=, you can quickly jump to any man entry using
Helm interface, either by typing in Helm prompt or if point is on a
symbol, get a man page at point. Give it a try.

*** Command: =helm-do-grep=
:PROPERTIES:
:ID:       fb36142a-6b14-4f9f-a6c1-d58d2a004ddc
:END:
In the first part, you already saw my live grep demo:

[[file:static/live_grep.gif][file:static/live_grep.gif]]

*C-c h g* (if you use my key bindings) or =M-x helm-do-grep= to
perform live grep as you typing. Use prefix argument for recursive
grep. You can also invoke =helm-do-grep= in =helm-find-files= session
with *C-s*.

*** Command: =helm-find=
:PROPERTIES:
:ID:       b7a95407-8629-48c4-bc9c-d0a391c95478
:END:
You can also quickly find a file with =helm-find=, binds to *C-c h f*
(in my configuration). As usual, when you type a character, Helm
filters candidates accordingly. Now, instead of typing a long find
query into terminal and wait, you have a simple Helm interface.

*** Command: =helm-locate=
:PROPERTIES:
:ID:       0e8e485d-c539-4175-9c81-9c8f9f17f608
:END:
Similar to =helm-find=, but you =locate= command, using *C-c h l* (in
my configuration). You can specify a local database with prefix argument.

*** Command: =helm-occur=
:PROPERTIES:
:ID:       5fe9a6c3-5af2-4b4a-94ff-5849560c831f
:END:
Similar to =occur=, but using Helm interface. As you type, matching
lines are updated immediately. Very interactively, as it is the nature
of Helm.

Demo: You can see that candidates kept getting updated when I was
typing. The demo starts when you see START in the minibuffer.

[[file:static/part3/helm-occur.gif][file:static/part3/helm-occur.gif]]

*** Command: =helm-apropos=
:PROPERTIES:
:ID:       479cdaab-0aba-48b8-b4d2-b026d23eb41a
:END:
Similar to *C-h a* which runs =apropos-command=, but use Helm
interface and update as you type.

*** Command: =helm-info-emacs=
:PROPERTIES:
:ID:       93e5fcb9-231b-43b8-81df-501a59bca2b6
:END:
In the extended config, I replace the default =info-emacs-manual= with
=helm-info-emacs=.

=helm= offers a wide ranges of info commands for various topics. =M-x
helm info= to see these commands, i.e. =helm-info-as=,
=helm-info-gdb=... You can search for info nodes easily with Helm
interface and *TAB* on an entry to view. *M-<next>* moves to the next
page, *M-<prior>* moves to the previous page in the other buffer.

You should bind your favourite info commands to some key bindings.
*** Command: =helm-resume=
:PROPERTIES:
:ID:       9d698347-33ee-447d-9fd1-eb01e9770dbb
:END:
    This command allows you to resume the previous Helm session, along
    with your previous patterns in the prompt. For example, if your
    last helm session was =helm-do-grep= and you entered patterns in
    Helm prompt, =helm-resume= resumes that session along with your
    previous input.

    This is really convenient when you have complex input ,and
    preparation steps. For example, if you have multiple regexp
    patterns in your previous Helm session, then you don't have to
    type it again. Or in your previous Helm session, you have to
    travel to a deep directory, and =helm-resume= helps you to reuse
    your previous session without going through all the troubles
    again.

*** Package: =helm-projectile=
:PROPERTIES:
:ID:       50cc1f5e-022d-4818-bedf-0a52e7e4615b
:END:
_Author_:  [[https://github.com/bbatsov][Bozhidar Batsov]], =bozhidar@batsov.com=

_Homepage_: [[https://github.com/bbatsov/projectile][Github]]

_Features_:

Provide Helm interface for quickly selecting files in a project using
Projectile.

[[file:static/helm_projectile.gif][file:static/helm_projectile.gif]]

_Installation_:

=M-x list-packages= and select *helm-projectile* package, then install
it. After finish installing, you can start using =helm-projectile=
immediately.

_Usage_:

*C-c p h* to run =helm-projectile= and select files in your project.

*** Package: =helm-descbind=
:PROPERTIES:
:ID:       3a128b01-725f-4142-bd0d-f9bbd4b715cc
:END:
_Author_

- 2008-2010:    Taiki SUGAWARA, =buzz.taiki@gmail.com=
- 2012-2013     Michael Markert, =markert.michael@googlemail.com=
- 2013-present: Daniel Hackney =dan@haxney.org=

_Homepage_: [[https://github.com/emacs-helm/helm-descbinds][Github]]

_Features_:
Helm Descbinds provides an interface to emacs’ describe-bindings
making the currently active key bindings interactively searchable with
helm.

Additionally you have the following actions

- Execute the command
- Describe the command
- Find the command

_Installation_:

=M-x list-packages= and select *helm-descbind* package, then install
it. After finish installing, add this code snippet to activate the
package:

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: helm-descbinds                      ;;
  ;;                                              ;;
  ;; GROUP: Convenience -> Helm -> Helm Descbinds ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'helm-descbinds)
  (helm-descbinds-mode)
#+end_src

_Usage_:

Enter a prefix key and *C-h* after it. You will see a list of bindings
using Helm interface for narrowing.

*** Why Helm is poweful
:PROPERTIES:
:ID:       260dfe60-eb43-4d20-b1c4-b51af5133a32
:END:
Helm's strengths:

- /_Simple and Consistent interface_/: Every Helm session starts with
  a same simple interface: a prompt for entering search patterns and
  a Helm buffer for displying results as a user types. Because of the
  consistency and simple interface, new people use Helm with ease.

- /_Interactivity_/: By nature, Helm is very interactive: as a user
  types, results get updated immediately in the Helm buffer. Because
  of this feature, Helm provides a unique interactive verion of many
  commmands that do not exist outside of Helm. For example,
  =helm-do-grep=, update grep results as you type.

- /_Matching mechanism_/: This is a powerful feature in Helm that I
  hvaen't seen in other packages: out of order matching, *with
  regex*. That's right, you can enter every search pattern as
  regex!. A really powerful concept: it enhances explanatory power for
  many things. One of use cases is exploring a new project: using
  Helm, you can "learn" the project structure interactively. For
  example, suppose I'm completely new to the linux kernel source tree,
  and I wonder whether a file =main.c= exists for =x86=
  architecture. I know that they must have =x86= directory somewhere,
  and the file could contain =main.c= in it, i.e. It can be =main.c=
  or =x86-main.c=. These are the only information I know, so I must
  confirm whether it is true or not, so I tried it in Helm:

  [[file:static/helm_projectile.gif][file:static/helm_projectile.gif]]

  It does exist. I also wonder where =i5100_edac.c= exists, because
  Intel has a datasheet for it a long time, so it must be
  implemented. As demonstrated in the above screencast, there was only
  one =i5100_eda.c=. Using other so-called "fuzzy-matching" mechanism,
  you are still required to know things in advanced and this severely
  limit the explanatory power. For example, to get to the file
  =driver/edac/i5100_edac.c=, you have to know the path to fuzzy
  match like this: =dedi51=; *d* for matching =driver=, *ed* for matching
  =edac= because other directories also start with "e"; *i51* for
  matching =i5100_edac.c= because serveral files also start with "i5",
  or contains "1" and "0" or "edac" in it. "i51" is the only unique
  prefix. Using Helm, you can immediately enter the unique pattern of
  a candidate and ignore the common prefix to get a candidate. For
  example, in the screencast above, I got =driver/edac/i5100_edac.c=
  immediately just by typing "*i51*" and the file was narrowed down.

  It's also not all that useful when using with a large source tree,
  since the source tree contains a large amount of files, and many of
  these files have same prefix.

- /Performance/: Helm can work with over 10000 candidates no problem.
